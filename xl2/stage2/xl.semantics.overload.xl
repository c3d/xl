// *****************************************************************************
// xl.semantics.overload.xl                                           XL project
// *****************************************************************************
//
// File description:
//
//     Implementation of overload resolution
//
//
//
//
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2004-2008,2015,2019, Christophe de Dinechin <christophe@dinechin.org>
// (C) 2004-2005, SÃ©bastien Brochet <sebbrochet@sourceforge.net>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import ITER = XL.SEMANTICS.ITERATORS
import REC = XL.SEMANTICS.TYPES.RECORDS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GN = XL.SEMANTICS.GENERICS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import GN = XL.SEMANTICS.GENERICS
import IO = XL.TEXT_IO


module XL.SEMANTICS.OVERLOAD is
// ----------------------------------------------------------------------------
//    Module implementing overload resolution
// ----------------------------------------------------------------------------

    procedure ArgsTreeToList(Args : PT.tree; in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert the input argument tree into a list
    // ------------------------------------------------------------------------
        if Args <> nil then
            translate Args
                when
                    'A', 'B'
                then
                    ArgsTreeToList A, List
                    ArgsTreeToList B, List

                when
                    ...
                then
                    VariadicExpr : PT.tree := GEN.VariadicExpression()
                    trace[overload] "Variadic: ", VariadicExpr
                    if VariadicExpr = nil then
                        ERR.Error "'$1' used outside of variadic context", Args
                        return
                    if not PT.Matches(VariadicExpr, parse_tree()) then
                        ArgsTreeToList VariadicExpr, List

                else
                    List += Args


    function Resolve(NameTree  : PT.tree;
                     Args      : PT.tree;
                     Input     : PT.tree;
                     forceCall : boolean) return BC.bytecode is
    // ------------------------------------------------------------------------
    //  Resolve the function name from its args
    // ------------------------------------------------------------------------
    //  When the arguments are nil, we return an overload set that can then
    //  be used by a higher-level overload resolution or written form
    //  and converted to the target type. This is used for Bar := Foo, where
    //  Bar and Foo are functions

        // Accelerate if this is "Pointer(3)" and we cannot deduce yet
        targetType      : PT.tree := TY.TargetType()
        if targetType = nil and PT.Attached(Input, "TODEDUCE") then
            trace[overload] "Cannot yet deduce ", Input
            return Input

        context         : SYM.symbol_table := XLT.context
        symbols         : SYM.symbol_table := context
        candidates      : PT.tree_list
        BaseRecord      : PT.tree
        anyLookup       : boolean := false
        callDepth       : integer := CGM.EnterCall()
        returnOverload  : boolean := not forceCall and Args = nil
        overloadSet     : PT.tree := nil
        ctorTarget      : PT.tree := PT.Attached(input, "CTORCALL")

        trace [+overload] "Overload resolution: name=", NameTree, " args=", Args
        if targetType <> nil then
            trace [overload] "Target type=", targetType

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when (any.'Name') then
                    anyLookup := true
                    NameTree := Name
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    FN : Field as PT.name_tree
                    // Check if we are looking for 'complex.value'
                    gt : GN.GenericIndex(Record, Field) as PT.name_tree
                    if gt <> nil then
                        NameTree := gt
                    else
                        REC.RecordDeclarations Record,FN,"FN",candidates,symbols
                        BaseRecord := XLT.XLSemantics(Record)
                        NameTree := Field
                else
                    ERR.Error "Internal: Non-name functor '$1'", NameTree
                    CGM.ExitCall callDepth, result
                    trace[-overload] "Non-name functor ", PT.Tree(NameTree)
                    return ERR.ErrorTree()
        Name : NameTree as PT.name_tree
        if Name = nil then
            ERR.Error "Cannot call non-name '$1'", NameTree
            return Input

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        ActArgs : PT.tree_list
        ToBeDef : string of boolean
        ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree

        // Scoring
        best      : PT.tree
        bestScore : integer
        bestF     : FN.function
        bestArgs  : PT.tree_list
        bestGArgs : GN.generic_map
        bestGtype : GEN.generic_type
        bestVArgs : PT.tree
        bestDNames: string of PT.name_tree
        bestDidx  : string of integer
        ambig     : PT.tree
        recurse   : boolean := BaseRecord = nil
        inIterator: boolean := FindInfo(Input, "ITERATOR_EXPR") <> nil

        // Additional conditions where we should directly resolve:
        // callDepth=0 corresponds to a top-level WriteLn call (not a function)
        // inIterator is because I can't imagine a case where "for foo loop"
        // would not mean that "foo" parameters would be evaluated
        if callDepth = 0 or inIterator then
            returnOverload := false
            forceCall := true

        // Save errors for later display
        ERR.PushErrorContext()

        // Perform semantics on all arguments
        for Arg in ArgList loop
            ToBeDefined : boolean := false
            if Arg.kind = PT.xlNAME and DCL.GetDeclaration(Arg) = nil then
                DName : Arg as PT.name_tree
                Dval  : text := Dname.value
                Orig  : PT.tree := SYM.LookupOne(context, "DECL", Dval)
                OrigF : PT.tree := SYM.LookupOne(context, "FN", Dval)
                OrigT : PT.tree := SYM.LookupOne(context, "TYPE", Dval)
                if Orig = nil and OrigF = nil and OrigT = nil then
                    ToBeDefined := true
                    trace[overload] "Arg ", Dval, " is to be defined"
            if not ToBeDefined then
                TY.PushTargetType nil
                Arg := XLT.XLSemantics (Arg)
                TY.PopTargetType()
            ActArgs += Arg
            ToBeDef += ToBeDefined
            trace [overload] "Args ", Arg, " type ", TY.Source(TY.GetType(Arg))

        // Add 'any' lookup as necessary
        if anyLookup then
            GN.AddInstantiators symbols, input

        // If there were errors while evaluating arguments, don't go further
        if ERR.PopErrorContext() then
            ERR.Error "Unable to evaluate arguments to '$1'", NameTree
            ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            trace[-overload] "Error evaluating arguments"
            return ERR.ErrorTree()
        ERR.PushErrorContext()

        // Lookup symbols at all relevant levels
        itemDepth  : map[PT.tree, integer]

        // Find all candidates at this level
        if recurse then
            SYM.Lookup symbols, "FN", Name.value, candidates, itemDepth, 2

            // Check if this is a type name. If so, we need to look all
            // possible constructor names
            types : PT.tree_list
            type  : PT.tree
            SYM.Lookup XLT.context, "TYPE", Name.value, types, itemDepth, 0
            for type in types loop
                tp    : TY.any_type := TY.GetDefinedType(type)
                ctors : PT.tree_list := DCL.ConstructorNames(tp)
                ctor  : PT.tree
                adjust: integer := 0
                for ctor in ctors loop
                    ctorName : ctor as PT.name_tree
                    if ctorName <> nil then
                        ctorList : PT.tree_list
                        adjust += 1
                        SYM.Lookup symbols, "FN", ctorName.value,
                                   candidates, itemDepth, adjust + 100

        trace [overload] "In table ", symbols,
                         " found ", size(candidates), " candidates"

        // Loop on candidates to check compatibility
        C : PT.tree
        for C in candidates loop

            Score : integer
            SYM.AdjustScoreDepth Score, itemDepth[C]
            SemArgs := ActArgs
            trace [overload] "Testing ", PT.name_tree(C), ":", C,
                             " depth ", itemDepth[C], " score ", Score

            // Retrieve function information, ignore non functions
            Scope : PT.tree := nil
            F : FN.function := FN.GetFunction(C)
            if F = nil then
                // We can get a record-prefixed value from a lateral map
                if recurse then
                    translate C
                        when ('Record'.'Fcall') then
                            F := FN.GetFunction(Fcall)
                            Scope := Record

                if F = nil then
                    ERR.Error "Internal: No function info for '$1'", C
                    trace [overload] "FAIL: No function info"
                    restart

            // If we are simply building an overload set, do it here
            if returnOverload then
                if overloadSet <> nil then
                    overloadSet := parse_tree
                        'overloadSet'
                        'C'
                else
                    overloadSet := C
                restart

            // Check if it is a generic function
            NStype: TY.any_type := TY.NonSourceType(F.Type)
            Ftype : NSType as FT.function_type
            Gtype : NSType as GEN.generic_type
            Gargs : GN.generic_map
            Vargs : PT.tree
            if Ftype = nil and Gtype <> nil then
                GFType : Gtype.base as FT.function_type
                Ftype := GFType
                SYM.AdjustScoreGenericity Score

            // Check that we actually have a function
            if Ftype = nil then
                NFtype : TY.any_type := F.type
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                trace[overload] "FAIL: Non-function ",
                                PT.tree(TY.Source(NFtype)),
                                " internal ", NFtype.machine_name
                restart

            // Check if it's an iterator, and if that matches usage
            iterator : F as ITER.iterator
            if (iterator <> nil) <> inIterator then
                if inIterator then
                    ERR.Error "'$1' is not an iterator", C
                else
                    ERR.Error "'$1' is not an iterator", C
                trace[overload] "FAIL: iterator mismatch ", C
                restart

            // Check number of parameters.
            NP : integer := size(Ftype.parameters)
            if Ftype.variadic then
                SYM.AdjustScoreVariadicity Score
                trace[overload] "Variadic ", TY.Source(Ftype), " score ", Score
            else if NA > NP then
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "there are too many arguments for '$1'", Name
                trace [overload] "FAIL: Too many arguments ",NA,">",NP
                restart

            // If we have a return type and a target type, check they match
            if targetType <> nil then
                retType : TY.any_type := FType.base
                if not GEN.IsGenericType(retType) then
                    tgTp : TY.any_type := TY.GetDefinedType(targetType)
                    matches : integer := TY.SameTypeRenames(retType, tgTp)
                    if matches = 0 then
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "the return type '$1'", TY.Source(retType)
                        ERR.Error "doesn't match expected type '$1'", targetType
                        trace[overload] "FAIL: Wrong return type, want ",
                                        targetType, " got ", TY.Source(retType)
                        restart
                    SYM.AdjustScoreRenames Score, matches

            // Check type of parameters
            D        : DCL.declaration
            Matching : boolean := true
            DNames   : string of PT.name_tree
            Didx     : string of integer
            A := 0
            for D in Ftype.parameters loop
                // F(A, B) is better than F(A, B, C) where C has a default
                // A += B is better than A+B for Add A, B
                SYM.AdjustScoreMatches Score, 1 + integer(D.is_output)
                if A < NA then
                    Arg := SemArgs[A]
                    if PT.Attached(Arg, "TODEDUCE") <> nil then
                        toType : PT.tree := TY.Source(D.type)
                        trace [overload] "Trying to deduce arg ", Arg
                        trace[overload] "Return type to deduce: ", toType

                        dt  : TY.any_type := D.type
                        dgt : dt as GEN.generic_type
                        if dgt <> nil then
                            trace[overload] "Type is generic, deferring"
                            A += 1
                            restart
                        else
                            tnt : XLT.attempt := XLT.BeginAttempt()
                            TY.PushTargetType toType
                            Arg := XLT.XLSemantics(Arg)
                            TY.PopTargetType()
                            if XLT.EndAttempt(tnt) then
                                Matching := false
                                ERR.Error "For candidate '$1'", C
                                ERR.Error "error deducing '$1'", SemArgs[A]
                                ERR.DisplayLastErrors()
                                exit if not Matching

                    if ToBeDef[A] then
                        if D.is_variable then
                            Dname : Arg as PT.name_tree
                            trace [overload] "Tentative undeclared ", Arg
                            DNames += Dname
                            Didx += A
                            A += 1
                            restart
                        else
                            trace[overload] "FAIL: Cannot declare ", Arg
                            trace[overload] "      non-out ", D.name
                else
                    Arg := D.initializer
                    if Arg = nil then
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "there is no value for '$1'", D.name
                        Matching := false
                        trace [overload] "No default argument "
                    else
                        SemArgs += XLT.XLSemantics (Arg)
                        trace [overload] "Testing default argument ", Arg
                        SYM.AdjustScoreDefaultValues Score
                    exit if not Matching
                assert Arg <> nil
                AType : TY.any_type := TY.GetType(Arg)
                if Gtype <> nil then
                    Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                else
                    if AType <> nil then
                        assignable : integer := DCL.Assignable(D, Arg)
                        Matching :=  assignable > 0
                        if Matching then
                            SYM.AdjustScoreRenames Score, assignable
                    else
                        Matching := false
                    if not Matching then
                        // Try implicit conversions
                        Arg := TY.TryConvert(Arg, D.type)
                        Matching := Arg <> nil and DCL.Assignable(D, Arg) > 0
                        if Matching then
                            trace[overload] "Implicit conversion to ",
                                            TY.Source(D.type)
                            trace[overload] "Expr=", Arg
                            SemArgs[A] := Arg
                            SYM.AdjustScoreConversions Score
                if not Matching then
                    if AType = nil then
                        AType := TY.InvalidType("unknown in overload")
                    trace [overload] "FAIL: Type mismatch for ",
                                     PT.tree(D.name)
                    trace [overload] "      Expected ", TY.Source(D.type),
                                     " = ", D.type
                    trace [overload] "      Got ", AType.name,
                                     " = ", AType
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                ArgList[A],
                                TY.Source(D.type), TY.Source(AType)
                    ERR.Error "for parameter '$1'", D.name
                    exit if not Matching
                A += 1
            if not Matching then
                restart

            // Check if this is a variadic and there are args left
            Vargs := nil
            if A < NA then
                assert Ftype.variadic
                Vargs := SemArgs[A]
                A += 1
                while A < NA loop
                    Arg := SemArgs[A]
                    Vargs := parse_tree ('Vargs', 'Arg')
                    A += 1
                trace[overload] "INFO: Variadics ", Vargs
            else if Ftype.variadic then
                Vargs := parse_tree()

            // Check if there are non-deduced generic arguments
            if Gtype <> nil then
                if not GN.FinalizeDeductions(Gtype, Gargs) then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the generic type '$1' cannot be deduced",
                              TY.Source(Gtype)
                    Matching := false
                    trace [overload] "FAIL: Cannot finalize deductions"

                // This is the case for Copy P, Pointer(3). Now we have
                // finalized deductions for P successfully, so we know
                // that P = pointer[znort], and consequently we can
                // use that information to deduce Pointer.
                A := 0
                for D in Ftype.parameters loop
                    exit if not Matching
                    if A < NA then
                        Arg := SemArgs[A]
                        if PT.Attached(Arg, "TODEDUCE") <> nil then
                            trace[deduce] "For overload ", C
                            trace[deduce] "will try deducing ", Arg
                            trace[deduce] "from type ", TY.Source(D.type),
                                          " of parameter ", PT.tree(D.name)

                            dt  : TY.any_type := D.type
                            dgt : dt as GEN.generic_type
                            if dgt <> nil then
                                inst : PT.tree := TY.Source(dgt)
                                inst := GN.InstantiateType(inst, Gargs)
                                trace[deduce] "instantiated as ", inst
                                dt := TY.GetDefinedType(inst)
                                trace[deduce] "of type ", TY.Source(dt)

                            tnt : XLT.attempt := XLT.BeginAttempt()
                            TY.PushTargetType TY.Source(dt)
                            Arg := XLT.XLSemantics(Arg)
                            TY.PopTargetType()
                            if XLT.EndAttempt(tnt) then
                                // Oh well, all this effort to fail now...
                                trace[deduce] "Err: ", ERR.LastErrorsText()
                                Matching := false
                            else
                                trace[deduce] "OK: ", Arg
                                SemArgs[A] := Arg
                    A += 1

            // If not matching, lookup next
            if not Matching then
                restart

            trace [overload] "PASS: Candidate ", C, " matches, score ", Score

            // Compare scores and results
            if best = nil then
                trace [overload] "BEST: Best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                bestDNames := DNames
                bestDidx := Didx
                if recurse then BaseRecord := Scope
            else if Score > bestScore then
                trace [overload] "BEST: New best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                bestDNames := DNames
                bestDidx := Didx
                if recurse then BaseRecord := Scope
            else if Score = bestScore and F <> bestF then
                ambig := C
                trace [overload] "AMBIGUOUS: Score ", Score
                trace [overload] "           Other: ", best

        // Remove 'any' context if we added it
        if anyLookup then
            GN.RemoveInstantiators symbols, input

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()

        // If we are returning the overload set, simply do it
        if returnOverload then
            result := parse_tree(@@overload 'NameTree' 'overloadSet')
            CGM.ExitCall callDepth, result
            TY.SetType result, TY.InvalidType("overload set")
            trace[-overload] "Return overload set"
            return result

        // Otherwise, check which one we would call
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The call to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", bestF.name
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Calling ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)

            if bestGtype <> nil or bestVargs <> nil then
                if bestGargs[nil] <> nil then
                    // Target type not set in that context yet, back up
                    assert TY.TargetType() = nil
                    CGM.ExitCall callDepth, result
                    PT.AttachTree Input, "TODEDUCE", Input
                    trace[-overload] "Must deduce result of ", PT.Tree(Input)
                    return Input
                result := GN.InstantiateFunction(NameTree, bestF,
                                                 bestGArgs, bestVargs,
                                                 BaseRecord)
                trace [overload] "INST: Instantiated as ", result
                bestF := FN.GetFunction(result)
                if bestF = nil then
                    // Instantiation error
                    CGM.ExitCall callDepth, result
                    trace[-overload] "Instantiation error ", result
                    return result
                trace [overload] "INST: new name ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
                trace [overload] "INST: new type ", TY.Source(bestF.type)

            // If there are parameters to declare, declare them now
            ctors        : PT.tree
            declaredHere : map[DCL.declaration, boolean]
            ftp          : TY.NonSourceType(bestF.type) as FT.function_type
            if callDepth = 0 and ftp.base <> nil and ctorTarget = nil then
                ERR.Error "The value returned by '$1' is ignored", NameTree
            if size(bestDNames) > 0 then
                ToDeclCount : integer := size(bestDNames)
                ToDecl      : integer
                for ToDecl in 0..ToDeclCount - 1 loop
                    DName : PT.name_tree := bestDNames[ToDecl]
                    Didx  : integer := bestDidx[ToDecl]
                    D     : DCL.declaration := ftp.parameters[Didx]
                    Local : DCL.Declaration :=
                        DCL.Declare (DName, D.type)
                    if D.is_input or not D.is_output then
                        ctors := XLT.Append(ctors,DCL.CallConstructor(Local))
                    if bestArgs[Didx] = PT.tree(DName) then
                        bestArgs[Didx] := XLT.XLSemantics(DName)
                    declaredHere[D] := true

            // Call the destructors for all output parameters
            // (the value will be constructed in the callee)
            dtors : PT.tree
            parm  : DCL.declaration
            P     : integer := 0
            for parm in ftp.parameters loop
                if parm.is_output and not parm.is_input then
                    if not declaredHere[parm] then
                        dtorCall : PT.tree := DCL.CallDestructor(bestArgs[P])
                        if dtorCall <> nil then
                            trace [calldtors] "Parm ", parm, " dtor ", dtorCall
                        dtors := XLT.Append(dtors, dtorCall)
                P += 1

            // Check if this is an iterator call
            iterator : bestF as ITER.iterator
            if iterator <> nil then
                result := ITER.InvokeIterator(Name, BaseRecord, iterator,
                                              bestArgs, ctors, dtors)
            else if BaseRecord <> nil then
                result := CGM.RecordFunctionCall (BaseRecord, bestF,
                                                  bestArgs, ctorTarget,
                                                  ctors, dtors)
            else
                result := CGM.FunctionCall (bestF, bestArgs, ctorTarget,
                                            ctors, dtors)
            if ctorTarget <> nil then
                PT.AttachTree Input, "CTORCALL", nil
        else
            ERR.Error "No valid function found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            trace[-overload] "No valid function found for ", PT.Tree(NameTree)
            return ERR.ErrorTree()

        // Destroy temporaries if necessary
        CGM.ExitCall callDepth, result

        trace[-overload] "Resolved ", Input, " as ", result


    procedure OverloadSetToList(overloadSet : PT.tree;
                                in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert an overload set to the individual function names
    // ------------------------------------------------------------------------
        if overloadSet <> nil then
            translate overloadSet
                when
                    'A'
                    'B'
                then
                    OverloadSetToList A, List
                    OverloadSetToList B, List

                else
                    List += overloadSet


    function ResolveOverload(NameTree    : PT.tree;
                             overloadSet : PT.tree;
                             toTypeExpr  : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //  Find which element of the overload set can match 'toType', if any
    // ------------------------------------------------------------------------
    //  When we write "Foo := Bar", where Foo and Bar are functions,
    //  the evaluation of "Bar" returns an overload set for all candidates.
    //  We then try to convert this overload set to a target type, and each
    //  time pick up whatever candidate is the most appropriate

        trace[overload] "Overload set ", overloadSet, " => ", toTypeExpr

        // Accelerate if this is "nil()" and we cannot deduce yet
        if TY.TargetType() = nil and PT.Attached(NameTree, "TODEDUCE") then
            trace[overload] "Overload set: cannot yet deduce ", NameTree
            return NameTree

        // Check the target type.
        toType : TY.any_type := TY.GetDefinedType(toTypeExpr)
        if toType = nil then
            ERR.Error "Overload target type '$1' has no type", toTypeExpr
            ERR.Error "Trying to resolve '$1'", NameTree
            return NameTree

        // If it is a function type, we will try to find the matching function
        toFnType : TY.NonSourceType(toType) as FT.function_type

        // Turn the overload set into a more usable tree list
        candidates : PT.tree_list
        OverloadSetToList overloadSet, candidates
        trace[overload] "Overload set: ", overloadSet
        trace[overload] "  size is ", size(candidates)

        // Scoring
        BaseRecord : PT.tree
        SemArgs    : PT.tree_list
        ActArgs    : PT.tree_list
        best       : PT.tree
        bestScore  : integer
        bestF      : FN.function
        bestArgs   : PT.tree_list
        bestGArgs  : GN.generic_map
        bestGtype  : GEN.generic_type
        bestVArgs  : PT.tree
        ambig      : PT.tree
        depth      : integer := 0
        callDepth  : integer := CGM.EnterCall()
        A          : integer

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on candidates to check compatibility
        C : PT.tree
        for C in candidates loop
            trace [overload] "Conversion: Testing ", C

            // Retrieve function information, ignore non functions
            Scope : PT.tree := nil
            F : FN.function := FN.GetFunction(C)
            if F = nil then
                // We can get a record-prefixed value from a lateral map
                translate C
                    when ('Record'.'Fcall') then
                        F := FN.GetFunction(Fcall)
                        Scope := Record

                if F = nil then
                    ERR.Error "Internal: No function info for '$1'", C
                    trace [overload] "FAIL: No function info"
                    restart

            // Check if it is a generic function
            NSType: TY.any_type := TY.NonSourceType(F.type)
            Ftype : NSType as FT.function_type
            Gtype : NSType as GEN.generic_type
            Gargs : GN.generic_map
            Vargs : PT.tree
            Score : integer := 0
            SYM.AdjustScoreDepth Score, depth

            if Ftype = nil and Gtype <> nil then
                GFType : Gtype.base as FT.function_type
                Ftype := GFType
                SYM.AdjustScoreGenericity Score

            // Check that we actually have a function
            if Ftype = nil then
                NFtype : TY.any_type := F.type
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                trace[overload] "FAIL: Non-function ",
                                PT.tree(TY.Source(NFtype)),
                                " internal ", NFtype.machine_name
                restart

            // Check number of parameters.
            NP : integer := size(Ftype.parameters)
            if Ftype.variadic then
                SYM.AdjustScoreVariadicity Score
            if toFnType <> nil then
                if NP <> size(toFnType.parameters) then
                    ERR.Error "'$1' could not be selected because of the", C
                    ERR.Error "different parameter count in '$1'", toTypeExpr
                    trace[overload] "FAIL: Parameter count mismatch"
                    restart
                if FType.variadic <> toFnType.variadic then
                    ERR.Error "'$1' could not be selected because of", C
                    ERR.Error "different variadicity in '$1'", toTypeExpr
                    trace[overload] "FAIL: Variadicity mismatch"
                    restart


            // Check type of parameters
            D        : DCL.declaration
            Matching : boolean := true
            A := 0
            for D in Ftype.parameters loop
                if toFnType <> nil then
                    toD : DCL.Declaration := toFnType.parameters[A]
                    assignable : integer := DCL.Assignable(D, toD.type)
                    Matching := assignable > 0
                    exit if not Matching
                    SYM.AdjustScoreRenames Score, assignable
                else
                    Arg : PT.tree := D.initializer
                    if Arg = nil then
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "there is no value for '$1'", D.name
                        Matching := false
                        trace [overload] "No default argument "
                    else
                        SemArgs += XLT.XLSemantics (Arg)
                        trace [overload] "Testing default argument ", Arg
                        SYM.AdjustScoreDefaultValues Score
                    exit if not Matching

                    AType : TY.any_type := TY.GetType(Arg)
                    if Gtype <> nil then
                        Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                    else
                        assignable : integer := DCL.Assignable(D, Arg)
                        Matching := assignable > 0
                        if Matching then
                            SYM.AdjustScoreRenames Score, assignable
                        else
                            // Try implicit conversions
                            Arg := TY.TryConvert(Arg, D.type)
                            Matching := Arg <> nil and DCL.Assignable(D,Arg) > 0
                            if Matching then
                                trace[overload] "Implicit conversion to ",
                                                TY.Source(D.type)
                                trace[overload] "Expr=", Arg
                                SemArgs[A] := Arg
                                SYM.AdjustScoreConversions Score
                    if not Matching then
                        trace [overload] "FAIL: Type mismatch for ",
                                         PT.tree(D.name)
                        trace [overload] "      Expected ", TY.Source(D.type),
                                         " : ", D.type
                        trace [overload] "      Got ", AType.name,
                                         " : ", AType
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                    D.initializer,
                                    TY.Source(D.type), TY.Source(AType)
                        ERR.Error "for parameter '$1'", D.name
                        exit if not Matching
                    A += 1
            if not Matching then
                restart

            // Check if there are non-deduced generic arguments
            if Gtype <> nil then
                if not GN.FinalizeDeductions(Gtype, Gargs) then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the generic type '$1' cannot be deduced",
                              TY.Source(Gtype)
                    Matching := false
                    trace [overload] "FAIL: Cannot finalize deductions"

            // If not matching, lookup next
            if not Matching then
                restart

            trace [overload] "PASS: The candidate matches"

            // Compare scores and results
            if best = nil then
                trace [overload] "BEST: Best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                BaseRecord := Scope
            else if Score > bestScore then
                trace [overload] "BEST: New best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                BaseRecord := Scope
            else if Score = bestScore and F <> bestF then
                ambig := C
                trace [overload] "AMBIGUOUS: Score ", Score
                trace [overload] "           Other: ", best

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()

        // Otherwise, check which one we would call
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The reference to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", bestF.name
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Resolved to ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)

            if bestGtype <> nil or bestVargs <> nil then
                if bestGargs[nil] <> nil then
                    // Target type not set in that context yet, back up
                    assert TY.TargetType() = nil
                    assert callDepth > 0
                    CGM.ExitCall callDepth, result
                    PT.AttachTree NameTree, "TODEDUCE", NameTree
                    return NameTree
                result := GN.InstantiateFunction(NameTree, bestF,
                                                 bestGArgs, bestVargs,
                                                 BaseRecord)
                trace [overload] "INST: Instantiated as ", result
                bestF := FN.GetFunction(result)
                if bestF = nil then
                    // Instantiation error
                    CGM.ExitCall callDepth, result
                    return result
                trace [overload] "INST: new name ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
                trace [overload] "INST: new type ", TY.Source(bestF.type)

            if toFnType <> nil then
                result := PT.Clone(bestF.machine_name)
                TY.SetType result, toFnType
            else if BaseRecord <> nil then
                result := CGM.RecordFunctionCall (BaseRecord, bestF,
                                                  bestArgs, nil, nil, nil)
            else
                result := CGM.FunctionCall (bestF, bestArgs, nil, nil, nil)

        else
            ERR.Error "No valid function found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            return ERR.ErrorTree()

        // Destroy temporaries if necessary
        CGM.ExitCall callDepth, result


    function IsFunctionNoConstructor(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function (excluding constructors)
    // ------------------------------------------------------------------------
        // Check that there is at least one function
        // If there is one, and if there is a local name, check that there
        // are local functions, otherwise, assume the local name takes over
        // external functions. This way, instantiationg XL.TEXT_IO.Write
        // doesn't break just because you happen to have a function called "F"
        // (which is otherwise visible during instantiation)
        Name        : T as PT.name_tree
        scope       : map[PT.tree, integer]
        funs        : PT.tree_list
        SYM.Lookup XLT.context, "FN", Name.value, funs, scope, 0
        trace[isfunc] "For ", T, " there are ", size(funs), " functions"
        if size(funs) = 0 then
            trace[isfunc] "No function named ", T
            return false        // No function at all

        dcls        : PT.tree_list
        dclDepth    : integer := 0
        SYM.Lookup XLT.context, "DECL", Name.value, dcls,
                   scope, dclDepth, SYM.lookupInnermost
        if size(dcls) = 0 then
            trace[isfunc] "Only functions named ", T, " - Success"
            return true         // There are functions, but no decl

        // This is a function name if the closest scope where we find a
        // function is at least as close as the first scope where we find
        // a non-function declaration
        trace[isfunc] "First function at ", scope[funs[0]],
                      " first decl at ", scope[dcls[0]]
        result := scope[funs[0]] <= scope[dcls[0]]
        trace[isfunc] "For ", T, " isfunction=", result


    function IsFunctionNoCache(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function (including constructors)
    // ------------------------------------------------------------------------

        if T.kind <> PT.xlNAME then
            translate T
                when (@ 'Stuff') then
                    return false
                when (any.'Name') then
                    trace[+isfunc] "Testing any.", Name
                    GN.AddInstantiators XLT.context, T
                    result := IsFunction(Name)
                    GN.RemoveInstantiators XLT.context, T
                    trace[-isfunc] "Testing any.", Name, " returned ", result
                    return result
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    trace[+isfunc] "Testing ", T
                    list : PT.tree_list
                    syms : SYM.symbol_table
                    FN : Field as PT.name_tree
                    // Check if we are looking for 'complex.value'
                    gt : GN.GenericIndex(Record, Field) as PT.name_tree
                    if gt <> nil then
                        GN.AddInstantiators XLT.context, gt
                        result := IsFunction(gt)
                        GN.RemoveInstantiators XLT.context, gt
                        trace[-isFunc] "From GenericIndex ", PT.tree(gt),
                                        " result ", result
                        return result
                    REC.RecordDeclarations Record, FN, "FN", list, syms
                    result := syms <> nil and size(list) > 0
                    trace[-isfunc] "Testing ", T, " returned ", result
                    return result
            return false

        Name        : T as PT.name_tree
        if Name.value = "@" then
            return false
        scope       : map[PT.tree, integer]
        types       : PT.tree_list
        type        : PT.tree
        SYM.Lookup XLT.context, "TYPE", Name.value, types, scope, 0
        trace [+isfunc] "Testing ", T, ", there are ", size(types), " types"
        for type in types loop
            tp    : TY.any_type := TY.GetDefinedType(type)
            ctors : PT.tree_list := DCL.ConstructorNames(tp)
            ctor  : PT.tree
            for ctor in ctors loop
                trace [isfunc] "Testing constructor ", ctor
                if IsFunctionNoConstructor(ctor) then
                    trace [-isfunc] "Found constructor ", ctor
                    return true

        result := IsFunctionNoConstructor(T)
        trace[-isfunc] "Result for ", T, " is ", result


    function IsFunction(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function, caches result
    // ------------------------------------------------------------------------
        if PT.Attached(T, "ISFUNC=0") then
            return false
        if PT.Attached(T, "ISFUNC=1") then
            return true
        result := IsFunctionNoCache(T)
        if result then
            PT.AttachTree T, "ISFUNC=1", T
        else
            PT.AttachTree T, "ISFUNC=0", T


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Overload resolution for function names
    // ------------------------------------------------------------------------

        when
            'FunctionName' ()
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil, input, true)

        when
            'FunctionName' 'FunctionArgs'
        where
            IsFunction (FunctionName)
        then
            block : FunctionArgs as PT.block_tree
            if block <> nil then
                if block.opening = "(" and block.closing = ")" then
                    FunctionArgs := block.child
            return Resolve(FunctionName, FunctionArgs, input, true)

