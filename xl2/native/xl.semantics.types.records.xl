// ****************************************************************************
//  xl.semantics.types.records.xl   (C) 1992-2004 Christophe de Dinechin (ddd)
//                                                                 XL2 project
// ****************************************************************************
//
//   File Description:
//
//    Implementation of record types
//
//
//
//
//
//
//
//
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision$
// * Date       : $Date$
// ****************************************************************************

import TY = XL.SEMANTICS.TYPES
import PT = XL.PARSER.TREE
import DCL = XL.SEMANTICS.DECLARATIONS
import CGM = XL.CODE_GENERATOR.MACHINE
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import GEN = XL.SEMANTICS.TYPES.GENERICS
import EN = XL.SEMANTICS.TYPES.ENUMERATIONS
import GN = XL.SEMANTICS.GENERICS


module XL.SEMANTICS.TYPES.RECORDS is
// ----------------------------------------------------------------------------
//    Implementation of the module
// ----------------------------------------------------------------------------

    function RecordTypeMatch(iface : any_type;
                             body : any_type) return boolean is
    // ------------------------------------------------------------------------
    //   Check if an interface type and a body type match for records
    // ------------------------------------------------------------------------
    //  Unlike for functions, we do not require an exact match, but that
    //  all declared fields can be found in the body symbol table
        ifaceR : iface as record_type
        bodyR  : body as record_type
        bodyC  : body as code_type

        if ifaceR = nil then
            ERR.Error "Internal: '$1' is not a record type", TY.Source(iface)
            return false
        if bodyC <> nil then
            assert bodyR = nil
            bodyR2 : bodyC.base as record_type
            if bodyR2 = nil then
                ERR.Error "Body '$1'is not a record type", TY.Source(Body)
                return false
            bodyR := bodyR2
        if bodyR = nil then
            ERR.Error "'$1' is not a record type", TY.Source(body)
            return false

        // Check base type
        baseType : any_type := ifaceR.base
        if not baseType.interface_match(baseType, bodyR.base) then
            ERR.Error "The base type of '$1'", TY.Source(bodyR)
            ERR.Error "doesn't match that of '$1'", TY.Source(ifaceR)
            return false

        // Check that the interface is implemented correctly
        if bodyC <> nil then
            // Since we checked that we have the same base, we can inject it
            if size(ifaceR.fields) > 0 then
                decl : declaration := ifaceR.fields[0]
                if TY.SameType (decl.type, baseType) then
                    old  : SYM.symbol_table := XLT.context
                    dname: PT.name_tree := decl.name
                    dname := PT.NewName(dname.value, dname.position)
                    XLT.context := bodyC.symbols
                    decl := DCL.Declare(dname, decl.type)
                    XLT.context := old
            result := DCL.MatchInterface(ifaceR.fields, bodyC.symbols)
            if result then
                if ifaceR.machine_name = nil or bodyC.machine_name <> nil then
                    ifaceR.machine_name := bodyC.machine_name
        else
            result := DCL.MatchInterface(ifaceR.fields, bodyR.symbols)
            if ifaceR.machine_name = nil or bodyR.machine_name <> nil then
                ifaceR.machine_name := bodyR.machine_name


    procedure MakeFieldList (Fields            : PT.tree;
                             in out rtp        : record_type) is
    // ------------------------------------------------------------------------
    //    Translate a field list from parse tree form into a list
    // ------------------------------------------------------------------------

        if Fields.kind = PT.xlBLOCK then
            block : Fields as PT.block_tree
            if (block.opening = XL.PARSER.INDENT_MARKER and
                block.closing = XL.PARSER.UNINDENT_MARKER) then
                MakeFieldList block.child, rtp
                return
            else
                ERR.Error "Block '$1' is not a valid field declaration", block

        translate Fields
            when
                'X' ; 'Y'
            then
                MakeFieldList X, rtp
                MakeFieldList Y, rtp

            when
                'X'
                'Y'
            then
                MakeFieldList X, rtp
                MakeFieldList Y, rtp

            else
                trace [recdecl] "Fields: ", Fields
                decl : DCL.declaration := DCL.GetDeclaration(Fields)
                if decl then
                    if not decl.is_builtin then
                        trace [recdecl] "Decl: ", decl
                        rtp.fields += decl
                else
                    translate Fields
                        when
                            'X'
                            'Y'
                        then
                            MakeFieldList X, rtp
                            MakeFieldList Y, rtp
                            return
                    ERR.Error "'$1' isn't a field declaration", Fields


    function NewRecordType(Source     : PT.tree;
                           Base       : PT.tree;
                           Fields     : PT.tree) return any_type is
    // ------------------------------------------------------------------------
    //    Create a basic type, possibly named (record_type or generic_type)
    // ------------------------------------------------------------------------
        rtp : record_type

        rtp.symbols := XLT.context

        // Check if empty field list. () is a block with an empty name
        if Fields <> nil and Fields.kind = PT.xlNAME then
            N : Fields as PT.name_tree
            if N.value = "" then
                Fields := nil

        // Add the base if there is one
        rtp.base := nil
        if Base <> nil then
            BaseType : any_type := TY.EvaluateType (Base)
            BaseName : PT.name_tree := PT.NewName("BaseRecord",Source.position)
            Decl : declaration := DCL.Declare(BaseName, BaseType)
            rtp.fields += Decl
            rtp.base := BaseType
            if GEN.IsGenericType (BaseType) then
                GEN.AddGenericDependency BaseType

        if Fields <> nil then
            if Fields.kind = PT.xlBLOCK then
                block : Fields as PT.block_tree
                Fields := block.child
            Fields := XLT.XLDeclarations(Fields)
            MakeFieldList Fields, rtp

        rtp.interface_match := RecordTypeMatch
        rtp.name := Source

        // Each record type gets a new machine name
        rtp.machine_name := SYM.Temporary("rec", Source.position)

        // If generic, make it generic
        if TY.IsModuleType(rtp.base) then
            if GEN.IsGenericContext() then
                // Do not make modules generic
                voided : any_type := GEN.MakeGeneric(rtp)
                voided := voided // Keep compiler quiet
            rtp.machine_name := CGM.DeclareRecord(rtp)
            result := rtp
        else if GEN.IsGenericContext() then
            rtp.machine_name := SYM.Temporary("<generic_record>")
            result := GEN.MakeGeneric(rtp)
        else
            rtp.machine_name := CGM.DeclareRecord(rtp)
            result := rtp

        TY.SetDefinedType rtp.machine_name, result


    function EnterType (Source  : PT.tree;
                        Base    : PT.tree;
                        Fields  : PT.tree) return PT.tree is
    // ------------------------------------------------------------------------
    //   Enter a type in the symbol table
    // ------------------------------------------------------------------------
    //   A type is entered in the symbol table as a simple replacement
    //   with the name, and the type info is attached to the name

        oldContext : SYM.symbol_table := XLT.context
        XLT.context := SYM.NewSymbolTable (XLT.context)
        SYM.SetInteger XLT.context, "FIELD", 1

        // Attach a type info to the original name
        tp : any_type := NewRecordType(Source, Base, Fields)
        TY.SetDefinedType Source, tp

        // Return the end type
        result := parse_tree (@type)
        TY.SetDefinedType result, tp

        XLT.context := oldContext


    // ========================================================================
    // 
    //   Properties of record types
    // 
    // ========================================================================

    function GetRecordBaseType(Record : PT.tree) return TY.any_type is
    // ------------------------------------------------------------------------
    //    Return the type of an expression
    // ------------------------------------------------------------------------

        // Evaluate record expression if type is not known
        tp : TY.any_type := TY.GetType(Record)
        if tp = nil then
            Record := XLT.XLSemantics(Record)
            if Record = nil then
                return nil
            tp := TY.GetType(Record)

        // Evaluate expression type
        rtp : TY.any_type := TY.NonConstedType(GEN.NonGenericType(tp))
        return rtp


    function GetRecordType(Record : PT.tree) return record_type is
    // ------------------------------------------------------------------------
    //    Return the type if it is a record type
    // ------------------------------------------------------------------------
        rtp : GetRecordBaseType(Record) as record_type
        return rtp


    function IsRecord (RecordExpr : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if something is a record
    // ------------------------------------------------------------------------
        Record   : PT.tree := RecordExpr
        hasDeref : boolean := true
        maxDeref : integer := 30

        // First look for "dereference" functions
        while hasDeref loop
            DerefCall : PT.tree := parse_tree(dereference 'Record')
            DerefCall := XLT.TentativeSemantics(DerefCall)
            hasDeref := DerefCall <> nil
            if hasDeref then
                maxDeref := maxDeref - 1
                if maxDeref <= 0 then
                    hasDeref := false
                Record := DerefCall

        ERR.PushErrorContext()
        result := GetRecordType (Record) <> nil
        if ERR.PopErrorContext() then
            result := false

        // Check the case where RecordExpr is a generic instance (A.size)
        if not result then
            tp : TY.any_type := GetRecordBaseType(Record)
            if tp <> nil then
                instance : PT.tree := TY.Source(tp)
                symbols  : SYM.symbol_table := GN.InstanceContext(instance)
                if symbols <> nil then
                    // This is another case we will deal with in 'Index'
                    result := true

        if result and RecordExpr <> Record then
            PT.AttachTree RecordExpr, "DEREF", Record
        trace[enum] "IsRecord ", RecordExpr, "=", integer(result)


    procedure RecordDeclarations(Record   : PT.tree;
                                 Field    : PT.name_tree;
                                 kind     : text;
                                 out defs : PT.tree_list;
                                 out syms : SYM.symbol_table) is
    // ------------------------------------------------------------------------
    //   Find the field definitions in a given record
    // ------------------------------------------------------------------------

        // Evaluate record expression
        tp : record_type := GetRecordType(Record)

        // Evaluate expression type
        if tp = nil then
            syms := nil
            return

        // Lookup field
        syms := tp.symbols
        SYM.Lookup syms, kind, Field.value, defs, SYM.lookupLocalOnly



    // ========================================================================
    // 
    //   Type evaluation
    // 
    // ========================================================================

    function IndexType(Record : PT.tree;
                       Field  : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Index a record element
    // ------------------------------------------------------------------------
        symbols     : SYM.symbol_table
        list        : PT.tree_list
        instParm    : PT.tree := nil
        ic          : SYM.symbol_table := GN.InstantiationContext()

        selected    : PT.tree := PT.Attached(Record, "DEREF")
        if selected <> nil then
            Record := selected

        RecordDeclarations Record, Field, "TYPE", list, symbols

        // Try to evaluate something like 'A.item' where A is an array
        tp : TY.any_type := GetRecordBaseType(Record)
        if tp <> nil then
            instance : PT.tree := TY.Source(tp)
            instContext : SYM.symbol_table := GN.InstanceContext(instance)
            if instContext <> nil then
                insts    : PT.tree_list
                SYM.Lookup instContext, "TYPE", Field.value,
                           insts, SYM.lookupLocalOnly
                if size(insts) > 0 then
                    instParm := insts[0]
                    if size(insts) > 1 then
                        ERR.Error "Instantiated name '$1' is ambiguous", Field
                        ERR.Error "A first candidate is '$1", insts[0]
                        ERR.Error "A second candidate is '$1", insts[1]

        // Otherwise, normal case
        if size(list) > 1 then
            ERR.Error "Type name '$1' is ambiguous", Field
            ERR.Error "A first candidate is '$1", list[0]
            ERR.Error "A second candidate is '$1", list[1]
        if instParm = nil then
            if symbols = nil then
                ERR.Error "No type for record '$1'", Record
            if size(list) = 0 then
                ERR.Error "Field '$1' doesn't exist", Field
                return parse_tree(@error)
            selected := list[0]
        else if size(list) > 0 then
            ERR.Error "Ambiguous type index for '$1'", Field
            ERR.Error "A first interpretation is parameter '$1'", instParm
            ERR.Error "A second interpretation is field '$1'", list[0]
        else
            selected := instParm

        // Lookup instance if instantiating 'IO.writable'
        // (here, IO itself is not generic, but writable is)
        if ic <> nil then
            insts : PT.tree_list
            SYM.Lookup ic, "TYPE", Field.value, insts, SYM.lookupLocalOnly
            if size(insts) > 0 then
                selected := insts[0]
                if size(insts) > 1 then
                    ERR.Error "Ambiguous generic type '$1'", Field
                    ERR.Error "A first interpretation is '$1'", insts[0]
                    ERR.Error "A second interpretation is '$1'", insts[1]

        // Find corresponding declaration
        decl : declaration := DCL.GetDeclaration(selected)
        if decl = nil then
            ERR.Error "Internal: Record field '$1' has no decl", Field
            return parse_tree(@error)


        // Find machine name of field
        dname  : PT.tree := decl.name
        dtype  : TY.any_type  := TY.GetDefinedType(dname)
        if dtype = nil then
            ERR.Error "Internal: Record field '$1' has no defined type", dname
            return parse_tree(@error)
        if TY.GetDefinedType(dtype.machine_name) = nil and dtype <> nil then
            TY.SetDefinedType dtype.machine_name, dtype
        return dtype.machine_name


    translation XLEvaluateType
    // ------------------------------------------------------------------------
    //    Translation of record types and record-indexed types
    // ------------------------------------------------------------------------
        when ('Base' with 'Fields') where TY.IsTypeName(Base) then
            return EnterType (input, Base, Fields)

        when ('Record'.'Field') where (Field.kind = PT.xlNAME) then

            result := GN.GenericIndex(Record, Field)
            if result = nil and IsRecord(Record) then
                FieldName : Field as PT.name_tree
                result := IndexType(Record, FieldName)
            return result



    // ========================================================================
    //
    //   Indexing
    //
    // ========================================================================

    function Index(Record : PT.tree;
                   Field  : PT.name_tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Index a record element
    // ------------------------------------------------------------------------
        symbols  : SYM.symbol_table
        list     : PT.tree_list
        selected : PT.tree := PT.Attached(Record, "DEREF")
        instParm : PT.tree := nil
        if selected <> nil then
            Record := selected

        RecordDeclarations Record, Field, "DECL", list, symbols

        // Find if there is an instantiation by that name locally
        tp : TY.any_type := GetRecordBaseType(Record)
        if tp <> nil then
            instance : PT.tree := TY.Source(tp)
            instContext : SYM.symbol_table := GN.InstanceContext(instance)
            if instContext <> nil then
                insts    : PT.tree_list
                SYM.Lookup instContext, "DECL", Field.value,
                           insts, SYM.lookupLocalOnly
                if size(insts) > 0 then
                    instParm := insts[0]
                    if size(insts) > 1 then
                        ERR.Error "Instantiated name '$1' is ambiguous", Field
                        ERR.Error "A first candidate is '$1", insts[0]
                        ERR.Error "A second candidate is '$1", insts[1]

        // Otherwise, normal case
        if size(list) > 1 then
            ERR.Error "Field '$1' is ambiguous", Field
            ERR.Error "A first candidate is '$1", list[0]
            ERR.Error "A second candidate is '$1", list[1]
        if instParm = nil then
            if symbols = nil then
                ERR.Error "No type for record '$1'", Record
            if size(list) = 0 then
                ERR.Error "Field '$1' doesn't exist", Field
                return parse_tree(@error)
            selected := list[0]
        else if size(list) > 0 then
            ERR.Error "Ambiguous index for $1", Field
            ERR.Error "A first interpretation is parameter $1", instParm
            ERR.Error "A second interpretation is field $1", list[0]
        else
            selected := instParm

        // Find corresponding declaration
        decl : declaration := DCL.GetDeclaration(selected)
        if decl = nil then
            ERR.Error "Internal: Record field '$1' has no decl", Field
            return parse_tree(@error)
        if instParm <> nil then
            if decl.initializer = nil then
                ERR.Error "Internal: No initializer for generic '$1'", instParm
            else
                return XLT.XLSemantics(decl.initializer)

        // Find machine name of field
        dtype  : TY.any_type  := decl.type
        mfield : PT.name_tree := decl.machine_name
        mtype  : PT.name_tree := dtype.machine_name

        // Index the result
        if TY.GetType(Record) = nil then
            Record := XLT.XLSemantics(Record)
        result := CGM.IndexRecord(Record, mfield, mtype, dtype)


    function EnterUsing (Record : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a lateral map in the local context
    // ------------------------------------------------------------------------
        callDepth : integer := CGM.EnterCall()
        Value     : PT.tree := XLT.XLSemantics(Record)
        rtp       : record_type := GetRecordType(Value)
        Code      : PT.tree

        CGM.SplitExpression Value, Code
        CGM.ExitCall callDepth, Code
        if rtp = nil then
            ERR.Error "The type of '$1' is not a record type", Record
        else
            SYM.AddUsing XLT.context, Value, rtp.symbols
        if Code = nil then
            Code := parse_tree(@nop)
        return Code


    function EnterDefaultFunction(source : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //    Create a default ctor/dtor in a lateral map
    // ------------------------------------------------------------------------
    //    We put it in a lateral map for two reasons:
    //    - It makes it possible to override it in the local scope
    //    - It is easier to destroy if there is any error

        // Save existing context, including global decls
        context : SYM.symbol_table := XLT.context
        globals : SYM.symbol_table := XLT.global_context

        // Create new symbol table
        newsyms : SYM.symbol_table := SYM.NewSymbolTable(context)
        XLT.context := newsyms
        XLT.global_context := newsyms

        trace[defaultfns] "In ", newsyms, "-", globals, " entering: ", source

        // Try to evaluate the tentative function
        tnt : XLT.attempt := XLT.BeginAttempt()
        result := XLT.XLDeclarations(source)
        result := XLT.XLSemantics(result)
        hadError : boolean := XLT.EndAttempt(tnt)
        XLT.context := context
        XLT.global_context := globals
        if hadError then
            trace[defaultfns] "Error: ", ERR.LastErrorsText()
            return nil

        trace[defaultfns] "Code: ", result

        // If evaluation was successful, then add the context as a lateral
        SYM.AddUsing context, nil, newsyms


    function EnterDefaultConstructor(recName : PT.name_tree;
                                     rtp : record_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a constructor built from defaults for all fields
    // ------------------------------------------------------------------------
    //   We create a tentative function body, which is created only
    //   if we can find defaults for all fields
        // Loop on all fields
        F    : declaration
        for F in rtp.fields loop
            if not TY.SameType (F.type, TY.type_of_records) then
                ftype : TY.Source(F.type) as PT.name_tree
                if ftype <> nil then
                    fname : PT.tree := PT.Clone(F.name)
                    ctorCall : PT.tree := parse_tree
                        result.'fname' := 'ftype' ()
                    result := XLT.Append(result, ctorCall)

        // If we found any, then generate a constructor here
        if result <> nil then
            result := parse_tree
                function 'recName' () return 'recName' is
                    'result'
            result := EnterDefaultFunction(result)


    function EnterFieldConstructor(recName : PT.name_tree;
                                   rtp : record_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a constructor taking a value for each field
    // ------------------------------------------------------------------------
    //   We create a tentative function body, which is created only
    //   if we can find copies for all fields
        // Loop on all fields
        F       : declaration
        Parms   : PT.tree
        for F in rtp.fields loop
            if not TY.SameType (F.type, TY.type_of_records) then
                ftype : PT.tree := TY.Source(F.type)
                fname : PT.tree := PT.Clone(F.name)
                pname : PT.tree := PT.Clone(F.name)
                ctorCall : PT.tree := parse_tree
                    result.'fname' := 'pname'
                result := XLT.Append(result, ctorCall)
                Parm   : PT.tree := parse_tree('pname' : 'ftype')
                Parms  := XLT.Append(Parms, parm)

        // If we found any, then generate a constructor here
        if result <> nil then
            result := parse_tree
                function 'recName'('Parms') return 'recName' is
                    'result'
            result := EnterDefaultFunction(result)


    function EnterDestructor(recName : PT.name_tree;
                             rtp : record_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a destructor deleting each field
    // ------------------------------------------------------------------------
    //  We always create the function body, which deletes what it can
    //  (i.e. individual 'delete' calls are tentative)

        // Loop on all fields
        F    : declaration
        for F in rtp.fields loop
            if not TY.SameType (F.type, TY.type_of_records) then
                fname : PT.tree := PT.Clone(F.name)
                dtorCall : PT.tree := parse_tree
                    delete this.'fname'
                result := XLT.Append(result, XLT.TentativeSemantics(dtorCall))

        // If we found any, then generate a 'delete' procedure here
        if result <> nil then
            result := parse_tree
                procedure delete (this : 'recName') is
                    'result'
            result := EnterDefaultFunction(result)


    function EnterCopy(recName : PT.name_tree;
                       rtp : record_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter a copy subroutine copying every field
    // ------------------------------------------------------------------------
    //  We create the copy routine only if we can copy all fields

        // Loop on all fields
        F    : declaration
        for F in rtp.fields loop
            if not TY.SameType (F.type, TY.type_of_records) then
                thisName : PT.tree := PT.Clone(F.name)
                thatName : PT.tree := PT.Clone(F.name)
                copyCall : PT.tree := parse_tree
                    this.'thisName' := that.'thatName'
                result := XLT.Append(result, copyCall)

        // If we found any, then generate a 'copy' procedure here
        if result <> nil then
            result := parse_tree
                procedure copy (out this:'recName';
                                that : 'recName') written this := that is
                    'result'
            result := EnterDefaultFunction(result)


    function EnterDefaults(N : PT.name_tree;
                           rtp : record_type) return BC.bytecode is
    // ------------------------------------------------------------------------
    //   Enter all the default functions for records
    // ------------------------------------------------------------------------
        result := XLT.Append(result, EnterDefaultConstructor(N, rtp))
        result := XLT.Append(result, EnterFieldConstructor(N, rtp))
        result := XLT.Append(result, EnterDestructor(N, rtp))
        result := XLT.Append(result, EnterCopy(N, rtp))


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Try to translate X.Y expressions
    // ------------------------------------------------------------------------
        when ('Record'.'Field') where (IsRecord(Record) and
                                       Field.kind = PT.xlNAME) then
            FieldName : Field as PT.name_tree
            return Index(Record, FieldName)

        when
            using 'Record'
        then
            return EnterUsing (Record)


