// ****************************************************************************
//  xl.semantics.overload.xl        (C) 1992-2004 Christophe de Dinechin (ddd) 
//                                                                 XL2 project 
// ****************************************************************************
// 
//   File Description:
// 
//     Implementation of overload resolution
// 
// 
// 
// 
// 
// 
// 
// 
// ****************************************************************************
// This document is released under the GNU General Public License.
// See http://www.gnu.org/copyleft/gpl.html for details
// ****************************************************************************
// * File       : $RCSFile$
// * Revision   : $Revision: 370 $
// * Date       : $Date: 2008-04-08 02:08:47 -0400 (Tue, 08 Apr 2008) $
// ****************************************************************************

import PT = XL.PARSER.TREE
import TY = XL.SEMANTICS.TYPES
import SYM = XL.SYMBOLS
import XLT = XL.TRANSLATOR
import ERR = XL.ERRORS
import FN = XL.SEMANTICS.FUNCTIONS
import FT = XL.SEMANTICS.TYPES.FUNCTIONS
import ITER = XL.SEMANTICS.ITERATORS
import REC = XL.SEMANTICS.TYPES.RECORDS
import GEN = XL.SEMANTICS.TYPES.GENERICS
import GN = XL.SEMANTICS.GENERICS
import CGM = XL.CODE_GENERATOR.MACHINE
import DCL = XL.SEMANTICS.DECLARATIONS
import GN = XL.SEMANTICS.GENERICS
import IO = XL.TEXT_IO


module XL.SEMANTICS.OVERLOAD is
// ----------------------------------------------------------------------------
//    Module implementing overload resolution
// ----------------------------------------------------------------------------

    procedure ArgsTreeToList(Args : PT.tree; in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert the input argument tree into a list
    // ------------------------------------------------------------------------
        if Args <> nil then
            translate Args
                when
                    'A', 'B'
                then
                    ArgsTreeToList A, List
                    ArgsTreeToList B, List

                when
                    ...
                then
                    VariadicExpr : PT.tree := GEN.VariadicExpression()
                    trace[overload] "Variadic: ", VariadicExpr
                    if VariadicExpr = nil then
                        ERR.Error "'$1' used outside of variadic context", Args
                        return
                    if not PT.Matches(VariadicExpr, parse_tree()) then
                        ArgsTreeToList VariadicExpr, List

                else
                    List += Args


    function Resolve(NameTree  : PT.tree;
                     Args      : PT.tree;
                     Input     : PT.tree;
                     forceCall : boolean) return BC.bytecode is
    // ------------------------------------------------------------------------
    //  Resolve the function name from its args
    // ------------------------------------------------------------------------
    //  When the arguments are nil, we return an overload set that can then
    //  be used by a higher-level overload resolution or written form
    //  and converted to the target type. This is used for Bar := Foo, where
    //  Bar and Foo are functions

        // Accelerate if this is "Pointer(3)" and we cannot deduce yet
        if TY.TargetType() = nil and PT.Attached(Input, "TODEDUCE") then
            trace[overload] "Cannot yet deduce ", Input
            return Input

        context         : SYM.symbol_table := XLT.context
        symbols         : SYM.symbol_table := context
        candidates      : PT.tree_list
        BaseRecord      : PT.tree
        anyLookup       : boolean := false
        callDepth       : integer := CGM.EnterCall()
        returnOverload  : boolean := not forceCall and Args = nil
        overloadSet     : PT.tree := nil
        ctorTarget      : PT.tree := PT.Attached(input, "CTORCALL")

        trace [+overload] "Overload resolution: name=", NameTree, " args=", Args
        if TY.TargetType() <> nil then
            trace [overload] "Target type=", TY.TargetType()

        if NameTree.kind <> PT.xlNAME then
            translate NameTree
                when (any.'Name') then
                    anyLookup := true
                    NameTree := Name
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    FN : Field as PT.name_tree
                    // Check if we are looking for 'complex.value'
                    gt : GN.GenericIndex(Record, Field) as PT.name_tree
                    if gt <> nil then
                        NameTree := gt
                    else
                        REC.RecordDeclarations Record,FN,"FN",candidates,symbols
                        BaseRecord := XLT.XLSemantics(Record)
                        NameTree := Field
                else
                    ERR.Error "Internal: Non-name functor '$1'", NameTree
                    CGM.ExitCall callDepth, result
                    trace[-overload] "Non-name functor ", PT.Tree(NameTree)
                    return parse_tree(@error)
        Name : NameTree as PT.name_tree
        if Name = nil then
            ERR.Error "Cannot call non-name '$1'", NameTree
            return Input

        // Convert arguments to a list for easier checking
        ArgList : PT.tree_list
        SemArgs : PT.tree_list
        ActArgs : PT.tree_list
        ToBeDef : string of boolean
        ArgsTreeToList Args, ArgList
        NA  : integer := size(ArgList)
        A   : integer
        Arg : PT.tree

        // Scoring
        best      : PT.tree
        bestScore : integer
        bestF     : FN.function
        bestArgs  : PT.tree_list
        bestGArgs : GN.generic_map
        bestGtype : GEN.generic_type
        bestVArgs : PT.tree
        bestDNames: string of PT.name_tree
        bestDidx  : string of integer
        ambig     : PT.tree
        recurse   : boolean := BaseRecord = nil
        inIterator: boolean := FindInfo(Input, "ITERATOR_EXPR") <> nil

        // Additional conditions where we should directly resolve:
        // callDepth=0 corresponds to a top-level WriteLn call (not a function)
        // inIterator is because I can't imagine a case where "for foo loop"
        // would not mean that "foo" parameters would be evaluated
        if callDepth = 0 or inIterator then
            returnOverload := false
            forceCall := true

        // Save errors for later display
        ERR.PushErrorContext()

        // Perform semantics on all arguments
        for Arg in ArgList loop
            ToBeDefined : boolean := false
            if Arg.kind = PT.xlNAME and DCL.GetDeclaration(Arg) = nil then
                DName : Arg as PT.name_tree
                Dval  : text := Dname.value
                Orig  : PT.tree := SYM.LookupOne(context, "DECL", Dval)
                OrigF : PT.tree := SYM.LookupOne(context, "FN", Dval)
                OrigT : PT.tree := SYM.LookupOne(context, "TYPE", Dval)
                if Orig = nil and OrigF = nil and OrigT = nil then
                    ToBeDefined := true
                    trace[overload] "Arg ", Dval, " is to be defined"
            if not ToBeDefined then
                TY.PushTargetType nil
                Arg := XLT.XLSemantics (Arg)
                TY.PopTargetType()
            ActArgs += Arg
            ToBeDef += ToBeDefined
            trace [overload] "Args ", Arg, " type ", TY.Source(TY.GetType(Arg))

        // Add 'any' lookup as necessary
        if anyLookup then
            GN.AddInstantiators symbols, input

        // If there were errors while evaluating arguments, don't go further
        if ERR.PopErrorContext() then
            ERR.Error "Unable to evaluate arguments to '$1'", NameTree
            ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            trace[-overload] "Error evaluating arguments"
            return parse_tree(@error)
        ERR.PushErrorContext()

        // Lookup symbols at all relevant levels
        itemDepth  : map[PT.tree, integer]

        // Find all candidates at this level
        if recurse then
            SYM.Lookup symbols, "FN", Name.value, candidates, itemDepth, 2

            // Check if this is a type name. If so, we need to look all
            // possible constructor names
            types : PT.tree_list
            type  : PT.tree
            SYM.Lookup XLT.context, "TYPE", Name.value, types, itemDepth, 0
            for type in types loop
                tp    : TY.any_type := TY.GetDefinedType(type)
                ctors : PT.tree_list := DCL.ConstructorNames(tp)
                ctor  : PT.tree
                for ctor in ctors loop
                    ctorName : ctor as PT.name_tree
                    if ctorName <> nil then
                        SYM.Lookup symbols, "FN", ctorName.value,
                                   candidates, itemDepth, 100

        trace [overload] "In table ", symbols,
                         " found ", size(candidates), " candidates"

        // Loop on candidates to check compatibility
        C : PT.tree
        for C in candidates loop

            Score : integer := itemDepth[C] + 1
            SemArgs := ActArgs
            trace [overload] "Testing ", PT.name_tree(C), ":", C,
                             " depth ", Score

            // Retrieve function information, ignore non functions
            Scope : PT.tree := nil
            F : FN.function := FN.GetFunction(C)
            if F = nil then
                // We can get a record-prefixed value from a lateral map
                if recurse then
                    translate C
                        when ('Record'.'Fcall') then
                            F := FN.GetFunction(Fcall)
                            Scope := Record

                if F = nil then
                    ERR.Error "Internal: No function info for '$1'", C
                    trace [overload] "FAIL: No function info"
                    restart

            // If we are simply building an overload set, do it here
            if returnOverload then
                if overloadSet <> nil then
                    overloadSet := parse_tree
                        'overloadSet'
                        'C'
                else
                    overloadSet := C
                restart

            // Check if it is a generic function
            Ftype : F.type as FT.function_type
            Gtype : F.type as GEN.generic_type
            Gargs : GN.generic_map
            Vargs : PT.tree
            if Ftype = nil and Gtype <> nil then
                GFType : Gtype.base as FT.function_type
                Ftype := GFType
                Score *= 100

            // Check that we actually have a function
            if Ftype = nil then
                NFtype : TY.any_type := F.type
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                trace[overload] "FAIL: Non-function ",
                                PT.tree(TY.Source(NFtype)),
                                " internal ", NFtype.machine_name
                restart

            // Check if it's an iterator, and if that matches usage
            iterator : F as ITER.iterator
            if (iterator <> nil) <> inIterator then
                if inIterator then
                    ERR.Error "'$1' is not an iterator", C
                else
                    ERR.Error "'$1' is not an iterator", C
                trace[overload] "FAIL: iterator mismatch ", C
                restart

            // Check number of parameters.
            NP : integer := size(Ftype.parameters)
            if Ftype.variadic then
                Score *= 100
                trace[overload] "Variadic ", TY.Source(Ftype), " score ", Score
            else if NA > NP then
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "there are too many arguments for '$1'", Name
                trace [overload] "FAIL: Too many arguments ",NA,">",NP
                restart

            // Check type of parameters
            D        : DCL.declaration
            Matching : boolean := true
            DNames   : string of PT.name_tree
            Didx     : string of integer
            A := 0
            for D in Ftype.parameters loop
                // F(A, B) is better than F(A, B, C) where C has a default
                // A += B is better than A+B for Add A, B
                if D.is_output then
                    Score += 1
                else
                    Score += 2
                if A < NA then
                    Arg := SemArgs[A]
                    if PT.Attached(Arg, "TODEDUCE") <> nil then
                        toType : PT.tree := TY.Source(D.type)
                        trace [overload] "Trying to deduce arg ", Arg
                        trace[overload] "Return type to deduce: ", toType

                        dt  : TY.any_type := D.type
                        dgt : dt as GEN.generic_type
                        if dgt <> nil then
                            trace[overload] "Type is generic, deferring"
                            A += 1
                            restart
                        else
                            tnt : XLT.attempt := XLT.BeginAttempt()
                            TY.PushTargetType toType
                            Arg := XLT.XLSemantics(Arg)
                            TY.PopTargetType()
                            if XLT.EndAttempt(tnt) then
                                Matching := false
                                ERR.Error "For candidate '$1'", C
                                ERR.Error "error deducing '$1'", SemArgs[A]
                                ERR.DisplayLastErrors()
                                exit if not Matching

                    if ToBeDef[A] then
                        if D.is_variable then
                            Dname : Arg as PT.name_tree
                            trace [overload] "Tentative undeclared ", Arg
                            DNames += Dname
                            Didx += A
                            A += 1
                            restart
                        else
                            trace[overload] "FAIL: Cannot declare ", Arg
                            trace[overload] "      non-out ", D.name
                else
                    Arg := D.initializer
                    if Arg = nil then
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "there is no value for '$1'", D.name
                        Matching := false
                        trace [overload] "No default argument "
                    else
                        SemArgs += XLT.XLSemantics (Arg)
                        trace [overload] "Testing default argument ", Arg
                    exit if not Matching
                assert Arg <> nil
                AType : TY.any_type := TY.GetType(Arg)
                if Gtype <> nil then
                    Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                else
                    if AType <> nil then
                        Matching := DCL.Assignable(D, Arg)
                    else
                        Matching := false
                    if not Matching then
                        // Try implicit conversions
                        Arg := TY.TryConvert(Arg, D.type)
                        Matching := Arg <> nil and DCL.Assignable(D, Arg)
                        if Matching then
                            trace[overload] "Implicit conversion to ",
                                            TY.Source(D.type)
                            trace[overload] "Expr=", Arg
                            SemArgs[A] := Arg
                            Score += 1 // Make it worse
                if not Matching then
                    if AType = nil then
                        AType := TY.InvalidType("unknown in overload")
                    trace [overload] "FAIL: Type mismatch for ",
                                     PT.tree(D.name)
                    trace [overload] "      Expected ", TY.Source(D.type)
                    trace [overload] "      Got ", AType.name
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                ArgList[A],
                                TY.Source(D.type), TY.Source(AType)
                    ERR.Error "for parameter '$1'", D.name
                    exit if not Matching
                A += 1
            if not Matching then
                restart

            // Check if this is a variadic and there are args left
            Vargs := nil
            if A < NA then
                assert Ftype.variadic
                Vargs := SemArgs[A]
                A += 1
                while A < NA loop
                    Arg := SemArgs[A]
                    Vargs := parse_tree ('Vargs', 'Arg')
                    A += 1
                trace[overload] "INFO: Variadics ", Vargs
            else if Ftype.variadic then
                Vargs := parse_tree()

            // Check if there are non-deduced generic arguments
            if Gtype <> nil then
                if not GN.FinalizeDeductions(Gtype, Gargs) then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the generic type '$1' cannot be deduced",
                              TY.Source(Gtype)
                    Matching := false
                    trace [overload] "FAIL: Cannot finalize deductions"

                // This is the case for Copy P, Pointer(3). Now we have
                // finalized deductions for P successfully, so we know
                // that P = pointer[znort], and consequently we can
                // use that information to deduce Pointer.
                A := 0
                for D in Ftype.parameters loop
                    exit if not Matching
                    if A < NA then
                        Arg := SemArgs[A]
                        if PT.Attached(Arg, "TODEDUCE") <> nil then
                            trace[deduce] "For overload ", C
                            trace[deduce] "will try deducing ", Arg
                            trace[deduce] "from type ", TY.Source(D.type),
                                          " of parameter ", PT.tree(D.name)

                            dt  : TY.any_type := D.type
                            dgt : dt as GEN.generic_type
                            if dgt <> nil then
                                inst : PT.tree := TY.Source(dgt)
                                inst := GN.InstantiateType(inst, Gargs)
                                trace[deduce] "instantiated as ", inst
                                dt := TY.GetDefinedType(inst)
                                trace[deduce] "of type ", TY.Source(dt)

                            tnt : XLT.attempt := XLT.BeginAttempt()
                            TY.PushTargetType TY.Source(dt)
                            Arg := XLT.XLSemantics(Arg)
                            TY.PopTargetType()
                            if XLT.EndAttempt(tnt) then
                                // Oh well, all this effort to fail now...
                                trace[deduce] "Err: ", ERR.LastErrorsText()
                                Matching := false
                            else
                                trace[deduce] "OK: ", Arg
                                SemArgs[A] := Arg
                    A += 1

            // If not matching, lookup next
            if not Matching then
                restart

            trace [overload] "PASS: Candidate ", C, " matches, score ", Score

            // Compare scores and results
            if best = nil then
                trace [overload] "BEST: Best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                bestDNames := DNames
                bestDidx := Didx
                if recurse then BaseRecord := Scope
            else if Score < bestScore then
                trace [overload] "BEST: New best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                bestDNames := DNames
                bestDidx := Didx
                if recurse then BaseRecord := Scope
            else if Score = bestScore and F <> bestF then
                ambig := C
                trace [overload] "AMBIGUOUS: Score ", Score
                trace [overload] "           Other: ", best

        // Remove 'any' context if we added it
        if anyLookup then
            GN.RemoveInstantiators symbols, input

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()

        // If we are returning the overload set, simply do it
        if returnOverload then
            result := parse_tree(@@overload 'NameTree' 'overloadSet')
            CGM.ExitCall callDepth, result
            TY.SetType result, TY.InvalidType("overload set")
            trace[-overload] "Return overload set"
            return result            

        // Otherwise, check which one we would call
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The call to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", bestF.name
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Calling ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)

            if bestGtype <> nil or bestVargs <> nil then
                if bestGargs[nil] <> nil then
                    // Target type not set in that context yet, back up
                    assert TY.TargetType() = nil
                    CGM.ExitCall callDepth, result
                    PT.AttachTree Input, "TODEDUCE", Input
                    trace[-overload] "Must deduce result of ", PT.Tree(Input)
                    return Input
                result := GN.InstantiateFunction(NameTree, bestF,
                                                 bestGArgs, bestVargs,
                                                 BaseRecord)
                trace [overload] "INST: Instantiated as ", result
                bestF := FN.GetFunction(result)
                if bestF = nil then
                    // Instantiation error
                    CGM.ExitCall callDepth, result
                    trace[-overload] "Instantiation error ", result
                    return result
                trace [overload] "INST: new name ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
                trace [overload] "INST: new type ", TY.Source(bestF.type)

            // If there are parameters to declare, declare them now
            ctors        : PT.tree
            declaredHere : map[DCL.declaration, boolean]
            ftp          : bestF.type as FT.function_type
            if callDepth = 0 and ftp.base <> nil and ctorTarget = nil then
                ERR.Error "The value returned by '$1' is ignored", NameTree
            if size(bestDNames) > 0 then
                ToDeclCount : integer := size(bestDNames)
                ToDecl      : integer
                for ToDecl in 0..ToDeclCount - 1 loop
                    DName : PT.name_tree := bestDNames[ToDecl]
                    Didx  : integer := bestDidx[ToDecl]
                    D     : DCL.declaration := ftp.parameters[Didx]
                    Local : DCL.Declaration :=
                        DCL.Declare (DName, D.type)
                    if D.is_input or not D.is_output then
                        ctors := XLT.Append(ctors,DCL.CallConstructor(Local))
                    if bestArgs[Didx] = PT.tree(DName) then
                        bestArgs[Didx] := XLT.XLSemantics(DName)
                    declaredHere[D] := true

            // Call the destructors for all output parameters
            // (the value will be constructed in the callee)
            dtors : PT.tree
            parm  : DCL.declaration
            P     : integer := 0
            for parm in ftp.parameters loop
                if parm.is_output and not parm.is_input then
                    if not declaredHere[parm] then
                        dtorCall : PT.tree := DCL.CallDestructor(bestArgs[P])
                        dtors := XLT.Append(dtors, dtorCall)
                P += 1

            // Check if this is an iterator call
            iterator : bestF as ITER.iterator
            if iterator <> nil then
                result := ITER.InvokeIterator(Name, BaseRecord, iterator,
                                              bestArgs, ctors, dtors)
            else if BaseRecord <> nil then
                result := CGM.RecordFunctionCall (BaseRecord, bestF,
                                                  bestArgs, ctorTarget,
                                                  ctors, dtors)
            else
                result := CGM.FunctionCall (bestF, bestArgs, ctorTarget,
                                            ctors, dtors)
            if ctorTarget <> nil then
                PT.AttachTree Input, "CTORCALL", nil
        else
            ERR.Error "No valid function found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            trace[-overload] "No valid function found for ", PT.Tree(NameTree)
            return parse_tree(@error)

        // Destroy temporaries if necessary
        CGM.ExitCall callDepth, result

        trace[-overload] "Resolved ", Input, " as ", result


    procedure OverloadSetToList(overloadSet : PT.tree;
                                in out List : PT.tree_list) is
    // ------------------------------------------------------------------------
    //   Convert an overload set to the individual function names
    // ------------------------------------------------------------------------
        if overloadSet <> nil then
            translate overloadSet
                when
                    'A'
                    'B'
                then
                    OverloadSetToList A, List
                    OverloadSetToList B, List

                else
                    List += overloadSet


    function ResolveOverload(NameTree    : PT.tree;
                             overloadSet : PT.tree;
                             toTypeExpr  : PT.tree) return BC.bytecode is
    // ------------------------------------------------------------------------
    //  Find which element of the overload set can match 'toType', if any
    // ------------------------------------------------------------------------
    //  When we write "Foo := Bar", where Foo and Bar are functions,
    //  the evaluation of "Bar" returns an overload set for all candidates.
    //  We then try to convert this overload set to a target type, and each
    //  time pick up whatever candidate is the most appropriate

        trace[overload] "Overload set ", overloadSet, " => ", toTypeExpr

        // Accelerate if this is "nil()" and we cannot deduce yet
        if TY.TargetType() = nil and PT.Attached(NameTree, "TODEDUCE") then
            trace[overload] "Overload set: cannot yet deduce ", NameTree
            return NameTree

        // Check the target type.
        toType : TY.any_type := TY.GetDefinedType(toTypeExpr)
        if toType = nil then
            ERR.Error "Overload target type '$1' has no type", toTypeExpr
            ERR.Error "Trying to resolve '$1'", NameTree
            return NameTree

        // If it is a function type, we will try to find the matching function
        toFnType : toType as FT.function_type

        // Turn the overload set into a more usable tree list
        candidates : PT.tree_list
        OverloadSetToList overloadSet, candidates
        trace[overload] "Overload set: ", overloadSet
        trace[overload] "  size is ", size(candidates)

        // Scoring
        BaseRecord : PT.tree
        SemArgs    : PT.tree_list
        ActArgs    : PT.tree_list
        best       : PT.tree
        bestScore  : integer
        bestF      : FN.function
        bestArgs   : PT.tree_list
        bestGArgs  : GN.generic_map
        bestGtype  : GEN.generic_type
        bestVArgs  : PT.tree
        ambig      : PT.tree
        depth      : integer := 0
        callDepth  : integer := CGM.EnterCall()
        A          : integer

        // Save errors for later display
        ERR.PushErrorContext()

        // Loop on candidates to check compatibility
        C : PT.tree
        for C in candidates loop
            trace [overload] "Conversion: Testing ", C

            // Retrieve function information, ignore non functions
            Scope : PT.tree := nil
            F : FN.function := FN.GetFunction(C)
            if F = nil then
                // We can get a record-prefixed value from a lateral map
                translate C
                    when ('Record'.'Fcall') then
                        F := FN.GetFunction(Fcall)
                        Scope := Record

                if F = nil then
                    ERR.Error "Internal: No function info for '$1'", C
                    trace [overload] "FAIL: No function info"
                    restart

            // Check if it is a generic function
            Ftype : F.type as FT.function_type
            Gtype : F.type as GEN.generic_type
            Gargs : GN.generic_map
            Vargs : PT.tree
            Score : integer := depth

            if Ftype = nil and Gtype <> nil then
                GFType : Gtype.base as FT.function_type
                Ftype := GFType
                Score *= 100

            // Check that we actually have a function
            if Ftype = nil then
                NFtype : TY.any_type := F.type
                ERR.Error "'$1' could not be selected because", C
                ERR.Error "it has non-function type '$1'", TY.Source(NFtype)
                trace[overload] "FAIL: Non-function ",
                                PT.tree(TY.Source(NFtype)),
                                " internal ", NFtype.machine_name
                restart

            // Check number of parameters.
            NP : integer := size(Ftype.parameters)
            if Ftype.variadic then
                Score *= 100
            if toFnType <> nil then
                if NP <> size(toFnType.parameters) then
                    ERR.Error "'$1' could not be selected because of the", C
                    ERR.Error "different parameter count in '$1'", toTypeExpr
                    trace[overload] "FAIL: Parameter count mismatch"
                    restart
                if FType.variadic <> toFnType.variadic then
                    ERR.Error "'$1' could not be selected because of", C
                    ERR.Error "different variadicity in '$1'", toTypeExpr
                    trace[overload] "FAIL: Variadicity mismatch"
                    restart
                    

            // Check type of parameters
            D        : DCL.declaration
            Matching : boolean := true
            A := 0
            for D in Ftype.parameters loop
                if toFnType <> nil then
                    toD : DCL.Declaration := toFnType.parameters[A]
                    Matching := DCL.Assignable(D, toD.type)
                    exit if not Matching
                else
                    Arg : PT.tree := D.initializer
                    if Arg = nil then
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "there is no value for '$1'", D.name
                        Matching := false
                        trace [overload] "No default argument "
                    else
                        SemArgs += XLT.XLSemantics (Arg)
                        trace [overload] "Testing default argument ", Arg
                    exit if not Matching

                    AType : TY.any_type := TY.GetType(Arg)
                    if Gtype <> nil then
                        Matching := GN.Deduce (Gtype, D, Arg, Gargs)
                    else
                        Matching := DCL.Assignable(D, Arg)
                        if not Matching then
                            // Try implicit conversions
                            Arg := TY.TryConvert(Arg, D.type)
                            Matching := Arg <> nil and DCL.Assignable(D, Arg)
                            if Matching then
                                trace[overload] "Implicit conversion to ",
                                                TY.Source(D.type)
                                trace[overload] "Expr=", Arg
                                SemArgs[A] := Arg
                                Score += 1 // Make it worse
                    if not Matching then
                        trace [overload] "FAIL: Type mismatch for ",
                                         PT.tree(D.name)
                        trace [overload] "      Expected ", TY.Source(D.type)
                        trace [overload] "      Got ", AType.name
                        ERR.Error "'$1' could not be selected because", C
                        ERR.Error "the type '$3' of '$1' doesn't match '$2'",
                                    D.initializer,
                                    TY.Source(D.type), TY.Source(AType)
                        ERR.Error "for parameter '$1'", D.name
                        exit if not Matching
                    A += 1
            if not Matching then
                restart

            // Check if there are non-deduced generic arguments
            if Gtype <> nil then
                if not GN.FinalizeDeductions(Gtype, Gargs) then
                    ERR.Error "'$1' could not be selected because", C
                    ERR.Error "the generic type '$1' cannot be deduced",
                              TY.Source(Gtype)
                    Matching := false
                    trace [overload] "FAIL: Cannot finalize deductions"

            // If not matching, lookup next
            if not Matching then
                restart

            trace [overload] "PASS: The candidate matches"

            // Compare scores and results
            if best = nil then
                trace [overload] "BEST: Best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                BaseRecord := Scope
            else if Score < bestScore then
                trace [overload] "BEST: New best score ", Score
                best := C
                bestScore := Score
                bestF := F
                bestArgs := SemArgs
                bestGArgs := Gargs
                bestGtype := Gtype
                bestVargs := Vargs
                BaseRecord := Scope
            else if Score = bestScore and F <> bestF then
                ambig := C
                trace [overload] "AMBIGUOUS: Score ", Score
                trace [overload] "           Other: ", best

        // Report results
        candidate_errors : boolean := ERR.PopErrorContext()

        // Otherwise, check which one we would call
        if best <> nil then
            if ambig <> nil then
                ERR.Error "The reference to '$1' is ambiguous", NameTree
                ERR.Error "A first candidate is '$1'", bestF.name
                ERR.Error "A second candidate is '$1'", ambig

            trace [overload] "FOUND: Resolved to ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)

            if bestGtype <> nil or bestVargs <> nil then
                if bestGargs[nil] <> nil then
                    // Target type not set in that context yet, back up
                    assert TY.TargetType() = nil
                    assert callDepth > 0
                    CGM.ExitCall callDepth, result
                    PT.AttachTree NameTree, "TODEDUCE", NameTree
                    return NameTree
                result := GN.InstantiateFunction(NameTree, bestF,
                                                 bestGArgs, bestVargs,
                                                 BaseRecord)
                trace [overload] "INST: Instantiated as ", result
                bestF := FN.GetFunction(result)
                if bestF = nil then
                    // Instantiation error
                    CGM.ExitCall callDepth, result
                    return result
                trace [overload] "INST: new name ", PT.tree(bestF.name),
                             "=", PT.tree(bestF.machine_name)
                trace [overload] "INST: new type ", TY.Source(bestF.type)

            if toFnType <> nil then
                result := PT.Clone(bestF.machine_name)
                TY.SetType result, toFnType
            else if BaseRecord <> nil then
                result := CGM.RecordFunctionCall (BaseRecord, bestF,
                                                  bestArgs, nil, nil, nil)
                ERR.Error "ResolveOverload '$1' not implemented", result
            else
                result := CGM.FunctionCall (bestF, bestArgs, nil, nil, nil)
                ERR.Error "ResolveOverload '$1' not implemented 2", result

        else
            ERR.Error "No valid function found for '$1'", NameTree
            if candidate_errors then
                ERR.DisplayLastErrors()
            CGM.ExitCall callDepth, result
            return parse_tree(@error)

        // Destroy temporaries if necessary
        CGM.ExitCall callDepth, result


    function IsFunction(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function (including constructors)
    // ------------------------------------------------------------------------
        if T.kind <> PT.xlNAME then
            translate T
                when (any.'Name') then
                    trace[+isfunc] "Testing any.", Name
                    GN.AddInstantiators XLT.context, T
                    result := IsFunction(Name)
                    GN.RemoveInstantiators XLT.context, T
                    trace[-isfunc] "Testing any.", Name, " returned ", result
                    return result
                when ('Record'.'Field') where Field.kind = PT.xlNAME then
                    trace[+isfunc] "Testing ", T
                    list : PT.tree_list
                    syms : SYM.symbol_table
                    FN : Field as PT.name_tree
                    // Check if we are looking for 'complex.value'
                    gt : GN.GenericIndex(Record, Field) as PT.name_tree
                    if gt <> nil then
                        return IsFunction(gt)
                    REC.RecordDeclarations Record, FN, "FN", list, syms
                    result := syms <> nil and size(list) > 0
                    trace[-isfunc] "Testing ", T, " returned ", result
                    return result
            return false

        Name        : T as PT.name_tree
        scope       : map[PT.tree, integer]
        types       : PT.tree_list
        type        : PT.tree
        SYM.Lookup XLT.context, "TYPE", Name.value, types, scope, 0
        trace [+isfunc] "Testing ", T, ", there are ", size(types), " types"
        for type in types loop
            tp    : TY.any_type := TY.GetDefinedType(type)
            ctors : PT.tree_list := DCL.ConstructorNames(tp)
            ctor  : PT.tree
            for ctor in ctors loop
                trace [isfunc] "Testing constructor ", ctor
                if IsFunctionNoConstructor(ctor) then
                    trace [-isfunc] "Found constructor ", ctor
                    return true

        result := IsFunctionNoConstructor(T)
        trace[-isfunc] "Result for ", T, " is ", result


    function IsFunctionNoConstructor(T : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //   Return true if a name indicates a function (excluding constructors)
    // ------------------------------------------------------------------------
        // Check that there is at least one function
        // If there is one, and if there is a local name, check that there
        // are local functions, otherwise, assume the local name takes over
        // external functions. This way, instantiationg XL.TEXT_IO.Write
        // doesn't break just because you happen to have a function called "F"
        // (which is otherwise visible during instantiation)
        Name        : T as PT.name_tree
        scope       : map[PT.tree, integer]
        funs        : PT.tree_list
        SYM.Lookup XLT.context, "FN", Name.value, funs, scope, 0
        trace[isfunc] "For ", T, " there are ", size(funs), " functions"
        if size(funs) = 0 then
            trace[isfunc] "No function named ", T
            return false        // No function at all

        dcls        : PT.tree_list
        dclDepth    : integer := 0
        SYM.Lookup XLT.context, "DECL", Name.value, dcls,
                   scope, dclDepth, SYM.lookupInnermost
        if size(dcls) = 0 then
            trace[isfunc] "Only functions named ", T, " - Success"
            return true         // There are functions, but no decl

        // This is a function name if the closest scope where we find a
        // function is at least as close as the first scope where we find
        // a non-function declaration
        trace[isfunc] "First function at ", scope[funs[0]],
                      " first decl at ", scope[dcls[0]]
        result := scope[funs[0]] <= scope[dcls[0]]
        trace[isfunc] "For ", T, " isfunction=", result


    translation XLSemantics
    // ------------------------------------------------------------------------
    //    Overload resolution for function names
    // ------------------------------------------------------------------------

        when
            'FunctionName' ('FunctionArgs')
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs, input, true)

        when
            'FunctionName' ()
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, nil, input, true)

        when
            'FunctionName' 'FunctionArgs'
        where
            IsFunction (FunctionName)
        then
            return Resolve(FunctionName, FunctionArgs, input, true)

