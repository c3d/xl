// *****************************************************************************
// xl.translator.xl                                                   XL project
// *****************************************************************************
//
// File description:
//
//     The basic XL translator
//
//
//
//
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2003-2008,2015,2018-2019, Christophe de Dinechin <christophe@dinechin.org>
// (C) 2004, SÃ©bastien Brochet <sebbrochet@sourceforge.net>
// (C) 2003, Juan Carlos Arevalo Baeza <thejcab@sourceforge.net>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

import PT = XL.PARSER.TREE
import PR = XL.PARSER
import IO = XL.TEXT_IO

module XL.TRANSLATOR is


    // ========================================================================
    //
    //     Temporary : forward references
    //
    // ========================================================================

    type args_map is map[text, integer]
    type enum_info is record with
        name  : text
        value : text
    type enum_list is string of enum_info

    procedure XL2C_Arg (input : PT.tree)
    procedure XL2C_Args (input : PT.tree)
    procedure XL2C_Stmt (input : PT.tree)
    procedure XL2C_Body (input : PT.tree; in_fn : boolean)
    procedure XL2C_Enum (input : PT.tree; out enums : enum_list)
    procedure XL2C_EnumName (name : PT.tree; enums : enum_list)
    procedure XL2C_Import (input : PT.tree; alias : PT.tree)
    procedure XL2C_PendingImports()
    procedure XL2C_Module (name : PT.tree; body : PT.tree)
    procedure XL2C_Namespace (name : PT.tree)
    procedure XL2C_Translate (what : PT.tree; how : PT.tree)
    procedure XL2C_SemanticsTranslation (Name : PT.name_tree; How : PT.tree)
    procedure XL2C_EarlyInit (What : PT.tree)
    procedure XL2C_LateCleanup (What : PT.tree)
    procedure XL2C_Quote (form : PT.tree; in out args : args_map; nesting : integer; wildcard : boolean)

    procedure XL2C(input : PT.tree)
    procedure Rename(from : text; to : text)
    function XLNormalize (name : text) return text
    function XLSanitize (str : text; quote : character) return text
    function XLModuleName (name : PT.tree) return text
    function XLModuleNameCPlus (name : text) return text
    function XLNamespaceScope (dot : PT.tree) return boolean


    // ========================================================================
    //
    //    Globals
    //
    // ========================================================================

    name_changes        : map [text, text]
    module_name         : map [text, text]
    module_imports      : map [text, integer]
    loop_index          : integer
    namespace_closing   : text := ""
    in_function         : boolean := false
    current_module      : text := ""
    translations        : map[text, int]
    traces              : map[text, int]
    trace_count         : integer := 0


    // ========================================================================
    //
    //    Top-level
    //
    // ========================================================================

    procedure EmitSemanticsPlugins is
    // ------------------------------------------------------------------------
    //    Emit the code for the SemanticsPlugins function
    // ------------------------------------------------------------------------

        IO.WriteLn "namespace xl { namespace translator {"

        IO.WriteLn "void pluginsinit() {"
        IO.WriteLn semantics_translations_init
        IO.WriteLn "}"

        T : text
        for T in translations loop
            T := XLNormalize(T)
            IO.WriteLn "xl::parser::tree::tree ", T, "("
            IO.WriteLn "xl::parser::tree::tree input) {"
            IO.WriteLn "return xl::symbols::lookuprewrite("
            IO.WriteLn "xl::translator::context, ", '"', T, '"', ", input);"
            IO.WriteLn "}"
        IO.WriteLn "}}"


    procedure EmitXLInitAndTerm is
    // ------------------------------------------------------------------------
    //   Emit the code for the XLInit() function
    // ------------------------------------------------------------------------
        IO.WriteLn "void XLInit() {"
        IO.WriteLn initializations
        IO.WriteLn "}"
        IO.WriteLn "void XLTerm() {"
        IO.WriteLn terminations
        IO.WriteLn "}"


        // Emit traces
        T : text
        IO.WriteLn "char XLTrace[", trace_count + 1, "] = { 0 };"
        IO.WriteLn "void XLTraceInit(int Argc, char **Argv) {"
        IO.WriteLn "int Arg; for (Arg = 1; Arg < Argc; Arg++) {";
        IO.WriteLn "::text N = Argv[Arg];"
        for T in traces loop
            IO.WriteLn "if (N == ""-t", T, """) XLTrace[", traces[T], "] = 1; "
        IO.WriteLn "}}"


    procedure Compile (input : PT.tree) is
    // ------------------------------------------------------------------------
    //   Rewrite the whole tree
    // ------------------------------------------------------------------------
        IO.writeln "#define XLINIT 1"
        IO.writeln "#include ", '"', "xl_lib.h", '"'

        rename "character",  "char"
        rename "integer",    "int"
        rename "real",       "double"
        rename "boolean",    "bool"
        rename "main",       "XLMain"
        rename "decltype",   "XLDeclType"

        rename ":=",         "="
        rename "=",          "=="
        rename "<>",         "!="
        rename "and",        "&&"
        rename "or",         "||"
        rename "xor",        "^"
        rename "bitwisenot", "~"
        rename "nil",        "0"

        rename "text",       "::text"

        XL2C input
        XL2C_PendingImports

        EmitSemanticsPlugins
        EmitXLInitAndTerm



    // ========================================================================
    //
    //    Implementation
    //
    // ========================================================================

    procedure Rename(from : text; to : text) is
    // ------------------------------------------------------------------------
    //   Indicate that we want to rename
    // ------------------------------------------------------------------------
         name_changes[from] := to


    function XLNormalize (name : text) return text is
    // ------------------------------------------------------------------------
    //    Return the normalized name (lower-case, no underscores)
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I : integer
        for I in 0..Max-1 loop
            C : character := name[I]
            if C <> '_' then
                result += ASCII.tolower C


    function XLSanitize (name : text; quote : character) return text is
    // ------------------------------------------------------------------------
    //    Adds C escapes and such as necessary
    // ------------------------------------------------------------------------
        result := ""
        Max : integer := length(name)
        I   : integer
        CR  : character := ASCII.CR[0]
        TAB : character := ASCII.TAB[0]
        esc : character := '\'

        for I in 0..Max-1 loop
            C : character := name[I]
            if C = CR then
                result += "\n"
            else if C = TAB then
                result += "\t"
            else if C = esc or C = quote then
                result := result + '\' + C
            else
                result += C


    procedure XL2C_Stmt (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------

        XL2C input
        if input.kind = PT.xlNAME then
            name : PT.name_tree := PT.name_tree(input)
            if name.value <> "return" then
                IO.write "()"
        IO.writeln ";"


    procedure XL2C_Body (input : PT.tree; in_fn : boolean) is
    // ------------------------------------------------------------------------
    //    Translate a statement
    // ------------------------------------------------------------------------
        old_in_function : boolean := in_function
        in_function := in_fn
        XL2C_Stmt input
        in_function := old_in_function


    procedure XL2C_Enum (input : PT.tree; out enums : enum_list) is
    // ------------------------------------------------------------------------
    //    Translate an enumeration list
    // ------------------------------------------------------------------------

        if input.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(input)
            XL2C_Enum T.child, enums
        else if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            E : enum_info
            IO.write N
            E.name := N
            E.value := T.value
            enums += E
        else
            translate input
                when
                    'A', 'B'
                then
                    XL2C_Enum A, enums
                    IO.WriteLn ","
                    XL2C_Enum B, enums
                when
                    'A'
                    'B'
                then
                    XL2C_Enum A, enums
                    IO.WriteLn ","
                    XL2C_Enum B, enums
                when
                    'A' = 'B'
                then
                    if A.kind = PT.xlNAME and B.kind = PT.xlTEXT then
                        TA : PT.name_tree := PT.name_tree(A)
                        TB : PT.text_tree := PT.text_tree(B)
                        N : text := XLNormalize(TA.value)
                        E : enum_info
                        IO.write N
                        E.name := N
                        E.value := TB.value
                        enums += E
                    else
                        IO.Writeln "Error: invalid named enum A=", A, " B=", B
                else
                    IO.Writeln "Error : invalid enum"


    procedure XL2C_EnumName(name : PT.tree; enums : enum_list)  is
    // ------------------------------------------------------------------------
    //    Translate an enumeration list
    // ------------------------------------------------------------------------
        I : integer
        Max : integer := size(enums)
        IO.write "inline const char *XLtext("
        XL2C name
        IO.writeln " x) {"
        IO.writeln "switch(x) {"
        for I in 0..Max-1 loop
            E : enum_info := enums[I]
            IO.writeln "case ", E.name, ": return """, E.value, """;"
        IO.write "default: return ""<Unknown "
        XL2C name
        IO.writeln " value>"";"
        IO.writeln "}}"


    procedure XL2C_Arg (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a single argument
    // ------------------------------------------------------------------------

        translate input

            // Input parameters stay as is
            when
                in 'A'
            then
                XL2C_Arg A

            // Input parameters stay as is
            when
                out 'A'
            then
                IO.write "&"
                XL2C_Arg A

            // By default, simply emit argument
            else
                XL2C input


    procedure XL2C_Args (input : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate the name portion of a procedure declaration
    // ------------------------------------------------------------------------

        translate input
            when
                'A' ; 'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A'
                'B'
            then
                XL2C_Args A
                IO.writeln ","
                XL2C_Args B

            when
                'A' : 'B' := 'DefaultValue'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A
                IO.write " = "
                XL2C DefaultValue

            when
                'A' : 'B'
            then
                XL2C B
                IO.write " "
                XL2C_Arg A


    procedure XL2C(input : PT.tree) is
    // ------------------------------------------------------------------------
    //    The main XL to C translator
    // ------------------------------------------------------------------------

        // --------------------------------------------------------------------
        //    Leafs
        // --------------------------------------------------------------------

        if input.kind = PT.xlNATURAL then
            T : PT.integer_tree := PT.integer_tree(input)
            IO.write T.value

        if input.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(input)
            IO.write T.value

        if input.kind = PT.xlTEXT then
            T : PT.text_tree := PT.text_tree(input)
            IO.write T.quote, XLSanitize(T.value, T.quote), T.quote

        if input.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(input)
            N : text := XLNormalize(T.value)
            if count(name_changes, N) > 0 then
                IO.write name_changes[N]
            else
                IO.write N


        // --------------------------------------------------------------------
        //   Special forms
        // --------------------------------------------------------------------

        if verbose then
            IO.Writeln "/* XL2C: ", input, " */"

        translate input

            // ----------------------------------------------------------------
            //    Sequences
            // ----------------------------------------------------------------

            when
                'A'
                'B'
            then
                if verbose then IO.Writeln "/* XL2C-Seq */"
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' ; 'B'
            then
                XL2C_Stmt A
                XL2C_Stmt B

            when
                'A' , 'B'
            then
                XL2C A
                IO.write ", "
                XL2C B


            // ----------------------------------------------------------------
            //   Special statements
            // ----------------------------------------------------------------

            when
                if 'A' then 'B' else 'C'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "} else {"
                XL2C_Stmt C
                IO.writeln "}"

            when
                if 'A' then 'B'
            then
                IO.write "if ("
                XL2C A
                IO.writeln ") {"
                XL2C_Stmt B
                IO.writeln "}"

            when
                loop 'A'
            then
                IO.writeln "for(;;) {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                while 'C' loop 'A'
            then
                IO.write "while ("
                XL2C C
                IO.writeln ") {"
                XL2C_Stmt A
                IO.writeln "}"

            when
                for 'I' loop 'Body'
            then
                loop_index += 1
                IO.write "XLIterator *XLiter", loop_index, " = "
                XL2C I
                IO.writeln ";"
                IO.writeln "for (XLiter", loop_index, "->first();"
                IO.write   "     XLiter", loop_index, "->more() || "
                IO.writeln     " XLDeleteIterator(XLiter", loop_index, ");"
                IO.writeln "     XLiter", loop_index, "->next())"
                IO.writeln "{"
                XL2C_Stmt Body
                IO.writeln "}"

            when
                exit if 'C'
            then
                IO.write "if ("
                XL2C C
                IO.writeln ") break;"

            when
                translate 'What'
                    'How'
            then
                IO.WriteLn "{"
                IO.WriteLn "bool XLtranslateDone = false;"
                IO.WriteLn "do {"
                XL2C_Translate What, How
                IO.WriteLn "} while (0);"
                IO.WriteLn "}"

            when
                translation 'Name'
                    'What'
            then
                if Name.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree (Name)
                    XL2C_SemanticsTranslation N, What

            when
                initially
                    'What'
            then
                XL2C_EarlyInit What

            when
                termination
                    'What'
            then
                XL2C_LateCleanup What


            // ----------------------------------------------------------------
            //   Declarations
            // ----------------------------------------------------------------

            // Procedure and function pointers
            when
                'Name' : procedure ( 'Args' )
            then
                IO.write "void (*"
                XL2C Name
                IO.write ")("
                XL2C_Args Args
                IO.writeln ");"
            when
                'Name' : procedure 'Name'
            then
                IO.write "void (*"
                XL2C Name
                IO.writeln ")(void);"

            when
                'Name' : function ( 'Args' ) return 'T'
            then
                XL2C T
                IO.write " (*"
                XL2C Name
                IO.write ")("
                XL2C_Args Args
                IO.writeln ");"
            when
                'Name' : function return 'T'
            then
                XL2C T
                IO.write " (*"
                XL2C Name
                IO.writeln ")(void);"

            when
                'A' : 'B' := 'C'
            then
                XL2C B
                IO.write " "
                XL2C A
                IO.write " = "
                XL2C C

            when
                'A' : 'B' is 'C'
            then
                IO.write "const "
                XL2C B
                IO.write " "
                XL2C A
                IO.write " = "
                XL2C C

            when
                'A' : 'B' as 'C'
            then
                XL2C C
                IO.write " "
                XL2C A
                IO.write " = dynamic_cast< "
                XL2C C
                IO.Write " > ("
                XL2C B
                IO.Write ")"

            when
                'A' : 'B'
            then
                next : PT.tree
                XL2C B
                IO.write " "
                while A <> nil loop
                    next := nil
                    translate A
                        when
                            'X','Y'
                        then
                            next := X
                            A := Y

                    XL2C A
                    if in_function then
                        IO.Write " = XLDefaultInit < "
                        XL2C B
                        IO.Write " > :: value()"
                    A := next
                    if A <> nil then
                        IO.Write ", "

            when
                import 'Shortcut' = 'ModName'
            then
                XL2C_Import ModName, Shortcut
            when
                import 'ModName'
            then
                XL2C_Import ModName, nil

            when
                module 'Name' with
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModWith */"
                XL2C_Module Name, Body
            when
                module 'Name' is
                    'Body'
            then
                if verbose then IO.Writeln "/* XL2C-ModBody */"
                XL2C_Module Name, Body
            when
                module 'Name'
            then
                if verbose then IO.Writeln "/* XL2C-ModName */"
                XL2C_Module Name, nil

            when
                type 'T' is record with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.writeln " {"
                 IO.write "virtual ~"
                 XL2C T
                 IO.writeln "(){}"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is 'Base' with
                   'Fields'
            then
                 IO.write "struct "
                 XL2C T
                 IO.write " : "
                 XL2C Base
                 IO.writeln " {"
                 XL2C_Body Fields, false
                 IO.writeln "};"
            when
                type 'T' is enumeration 'Values'
            then
                // Emit the enum type itself
                enums : enum_list
                IO.write "enum "
                XL2C T
                IO.Writeln " {"
                XL2C_Enum Values, enums
                IO.Writeln "};"

                // Emit the text conversion function
                // XL2C_EnumName T, enums

            when
                type 'Name' is procedure ( 'Args' )
            then
                IO.write "typedef void (*"
                XL2C Name
                IO.write ")("
                XL2C_Args Args
                IO.writeln ");"
            when
                type 'Name'  is procedure
            then
                IO.write "typedef void (*"
                XL2C Name
                IO.writeln ")(void);"

            when
                type 'Name' is function ( 'Args' ) return 'T'
            then
                IO.write "typedef "
                XL2C T
                IO.write " (*"
                XL2C Name
                IO.write ")("
                XL2C_Args Args
                IO.writeln ");"
            when
                type 'Name' is function return 'T'
            then
                IO.write "typedef "
                XL2C T
                IO.write " (*"
                XL2C Name
                IO.writeln ")(void);"

            when
                type 'X' is 'Y'
            then
                IO.write "typedef "
                XL2C Y
                IO.write " "
                XL2C X
                IO.writeln ";"

            when
                type 'T'
            then
                IO.write "struct "
                XL2C T
                IO.writeln ";"

            // Functions and procedures
            when
                procedure 'Name' ( 'Args' ) is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"
                XL2C_Body Body, true
                IO.writeln "}"
            when
                procedure 'Name' is
                    'Body'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"

            when
                function 'Name' ( 'Args' ) return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ") {"

                XL2C T
                IO.Write " result = XLDefaultInit < "
                XL2C T
                IO.WriteLn " > ::value();"

                IO.WriteLn "{"
                XL2C_Body Body, true
                IO.WriteLn "}"
                IO.WriteLn "return result;"
                IO.writeln "}"
            when
                function 'Name' return 'T' is
                    'Body'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void) {"
                XL2C_Body Body, true
                IO.writeln "}"


            // Declaration-only for functions and procedures
            when
                procedure 'Name' ( 'Args' )
            then
                IO.write "void "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                procedure 'Name'
            then
                IO.write "void "
                XL2C Name
                IO.writeln "(void);"

            when
                function 'Name' ( 'Args' ) return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.write "("
                XL2C_Args Args
                IO.writeln ");"
            when
                function 'Name' return 'T'
            then
                XL2C T
                IO.write " "
                XL2C Name
                IO.writeln "(void);"


            // ----------------------------------------------------------------
            //   Expressions
            // ----------------------------------------------------------------

            when
                'A' ['B'..'C']
            then
                IO.write "range("
                XL2C A
                IO.write ", XLMakeRange("
                XL2C B
                IO.Write ", "
                XL2C C
                IO.write "))"

            when // Temporary hack for enums...
                text 'A'
            then
                IO.Write "XLtext("
                XL2C A
                IO.Write ")"

            when
                'A' in 'B'
            then
                IO.write "XLMakeIterator("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' .. 'B'
            then
                IO.write "XLMakeRange("
                XL2C A
                IO.write ", "
                XL2C B
                IO.write ")"

            when
                'A' . 'B'
            then
                if XLNamespaceScope (A) then
                    IO.Write "::"
                else
                    IO.Write "."
                XL2C B

            when
                parse_tree
                    'A'
            then
                args : args_map
                XL2C_Quote A, args, 2, false
            when
                parse_tree ('A')
            then
                args : args_map
                XL2C_Quote A, args, 2, false


            // ----------------------------------------------------------------
            //   Some special case...
            // ----------------------------------------------------------------

            when
                map['A','B']
            then
                IO.write "std::map < "
                XL2C A
                IO.write ", "
                XL2C B
                IO.write " > "

            when
                access to 'A'
            then
                XL2C A
                IO.write "* "

            when
                string of 'A'
            then
                IO.write "std::vector < "
                XL2C A
                IO.write " > "

            when
                trace ['A'] 'B'
            then
                indent : integer := 0
                translate A
                    when
                        +'X'
                    then
                        indent := 1
                        A := X
                    when
                        -'X'
                    then
                        indent := -1
                        A := X
                if A.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree(A)
                    tname : text := XLNormalize(N.value)
                    if count(traces, tname) = 0 then
                        trace_count += 1
                        traces[tname] := trace_count
                    IO.Write "{ if (XLTrace[", traces[tname], "]) {"
                    IO.Write " XLTraceName(""", tname, """);"
                    IO.Write " xl::textio::writeln(";
                    XL2C B
                    IO.Write ");"
                    if indent <> 0 then
                        IO.Write "XLTraceIndent += ", indent, ";"
                    IO.WriteLn "}}"


            // ----------------------------------------------------------------
            //   Other cases...
            // ----------------------------------------------------------------

            else

                // For non-atoms, check recursively
                if input.kind = PT.xlBLOCK then
                    T : PT.block_tree := PT.block_tree(input)
                    if T.opening = PR.INDENT_MARKER then
                        IO.writeln "{"
                        XL2C_Stmt T.child
                        IO.writeln "}"
                    else
                        IO.write T.opening
                        XL2C T.child
                        IO.write T.closing


                if input.kind = PT.xlPREFIX then
                    T : PT.prefix_tree := PT.prefix_tree(input)
                    R : PT.tree := T.right

                    XL2C T.left
                    if R.kind <> PT.xlBLOCK then
                        IO.write " ("
                        XL2C R
                        IO.write ")"
                    else
                        IO.write " "
                        XL2C R

                if input.kind = PT.xlINFIX then
                    T : PT.infix_tree := PT.infix_tree(input)
                    N : text := XLNormalize(T.name)
                    if count(name_changes, N) > 0 then
                        N := name_changes[N]

                    XL2C T.left
                    IO.write " ", N, " "
                    XL2C T.right


    function XLModuleName (name : PT.tree) return text is
    // ------------------------------------------------------------------------
    //   Return the XL module name for A.B.C
    // ------------------------------------------------------------------------
        translate name
            when
                'A' . 'B'
            then
                result := XLModuleName(A)
                result += "."
                result += XLModuleName(B)

            else
                if name.kind = PT.xlNAME then
                    N : PT.name_tree := PT.name_tree(name)
                    modname : text := XLNormalize(N.value)
                    if count (module_name, modname) = 0 then
                        module_name[modname] := modname
                    result := modname


    function XLModuleNameCPlus (name : text) return text is
    // ------------------------------------------------------------------------
    //   Return the C++ module name for A.B.C
    // ------------------------------------------------------------------------
        I          : integer
        max        : integer := length name

        result := ""
        for I in 0..max-1 loop
            C : character := name[I]
            if C = '.' then
                result += "::"
            else
                result += C


    procedure XL2C_Import (modname : PT.tree; alias : PT.tree) is
    // ------------------------------------------------------------------------
    //    Deal with import clauses
    // ------------------------------------------------------------------------

        imported      : text := XLModuleName(modname)
        cplusified    : text := XLModuleNameCPlus(imported)
        done          : integer := 0

        if alias <> nil then
            alias_name : text := XLModuleName(alias)
            module_name[alias_name] := cplusified
        module_name[imported] := cplusified

        interface_name : text := imported + ".xs"

        done := module_imports[imported]
        if (done & 1) = 0 then
            iface_parser : PR.parser := PR.NewParser(interface_name)
            iface_tree   : PT.tree := PR.Parse(iface_parser)
            IO.WriteLn ""
            IO.WriteLn "// Interface ", interface_name, " done=", done
            module_imports[imported] |= 1
            if iface_tree <> nil then
                XL2C_Stmt iface_tree
                done |= 1
            IO.WriteLn ""
            IO.WriteLn "// End of Interface ", interface_name, " done=", done


    procedure XL2C_PendingImports() is
    // ------------------------------------------------------------------------
    //    Emit code for pending imports
    // ------------------------------------------------------------------------

        someChange : boolean := true
        while someChange loop
            imported   : text
            someChange := false
            for imported in module_imports loop
                exit if someChange
                if (module_imports[imported] & 2) = 0 then
                    body_name      : text := imported + ".xl"
                    IO.WriteLn ""
                    IO.WriteLn "// Body ", body_name
                    body_parser : PR.parser := PR.NewParser(body_name)
                    body_tree   : PT.tree := PR.Parse(body_parser)
                    module_imports[imported] |= 2
                    if body_tree <> nil then
                        XL2C_Stmt body_tree
                        someChange := true
                    IO.WriteLn ""
                    IO.WriteLn "// End of Body ", body_name


    procedure XL2C_Namespace (name : PT.tree) is
    // ------------------------------------------------------------------------
    //   Translate a module
    // ------------------------------------------------------------------------

        translate name
            when
               'A' . 'B'
            then
               XL2C_Namespace A
               IO.writeln " {"
               XL2C_Namespace B
               namespace_closing += "}"
            else
               IO.write "namespace "
               XL2C name
               if name.kind = PT.xlNAME then
                   N : PT.name_tree := PT.name_tree(name)
                   current_module += XLNormalize(N.value)
                   current_module += "::"


    procedure XL2C_Module (name : PT.tree; body : PT.tree) is
    // ------------------------------------------------------------------------
    //    Display a module
    // ------------------------------------------------------------------------

         current_module := ""
         XL2C_Namespace name
         if body <> nil then
             IO.WriteLn " {"
             XL2C_Stmt body
             IO.WriteLn " } ", namespace_closing
         else
             IO.Writeln " {} ", namespace_closing
         namespace_closing := ""


    function XLNamespaceScope (name : PT.tree) return boolean is
    // ------------------------------------------------------------------------
    //    Return true if the name denotes a namespace scope
    // ------------------------------------------------------------------------

        if name.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree (name)
            N : text := XLNormalize (T.value)
            if count (module_name, N) > 0 then
                IO.Write module_name[N]
                return true
            else
                IO.Write "XLDeref(", N, ")"
                return false

        translate name
            when
                'X' . 'Y'
            then
                if XLNamespaceScope (X) then
                    IO.Write "::"
                else
                    IO.Write "."
                return XLNamespaceScope(Y)

        IO.Write "XLDeref("
        XL2C name
        IO.Write ")"
        return false


    // ========================================================================
    //
    //    Translate translate
    //
    // ========================================================================

    procedure XL2C_Quote (form : PT.tree; in out args : args_map; nesting : integer; wildcard : boolean) is
    // ------------------------------------------------------------------------
    //    Emit the code for the translate form
    // ------------------------------------------------------------------------

        I : integer
        for I in 1..nesting loop
            IO.Write ' '

        // For each kind of atom, check and return 0 or 1
        if form.kind = PT.xlNATURAL then
            T : PT.integer_tree := PT.integer_tree(form)
            IO.Write "xl::parser::tree::newnatural(", T.value, ")"

        if form.kind = PT.xlREAL then
            T : PT.real_tree := PT.real_tree(form)
            IO.Write "xl::parser::tree::newreal(", T.value, ")"

        if form.kind = PT.xlTEXT then
            // 'A' or "A" is transformed into a name
            // '"A"' or "'A'" is transformed into corresponding string
            T : PT.text_tree := PT.text_tree(form)
            quote : character := character(0)
            is_quote : boolean := false
            if length(T.value) > 2 then
               quote := T.value[0]
               if quote <> T.value[length(T.value)-1] then
                   quote := character(0)
               else
                   is_quote := ASCII.is_quote(quote)

            if is_quote then
                // The normal syntax would be T.value[1..length(T.value)-2]
                // but our current Advanced Fuzzy Compilation Technology (TM)
                // doesn't support that yet.
                contents : text := range (T.value, 1..length(T.value)-2)
                IO.Write "xl::parser::tree::newtext(text("""
                IO.Write XLSanitize(contents, '"')
                IO.Write """), "
                IO.Write "'", XLSanitize(text("") + quote, ''''), "')"
            else
                if wildcard then
                    IO.Write "xl::parser::tree::newwildcard(text("""
                    IO.Write XLSanitize(XLNormalize(T.value), '"'), """))"
                else
                    // We should check that it's a single name
                    IO.Write XLNormalize(T.value)
            args[T.value] := 1

        if form.kind = PT.xlNAME then
            T : PT.name_tree := PT.name_tree(form)
            IO.Write "xl::parser::tree::newname(text(""", XLNormalize(T.value), """))"

        // For non-atoms, check recursively
        if form.kind = PT.xlBLOCK then
            T : PT.block_tree := PT.block_tree(form)
            IO.Writeln "xl::parser::tree::newblock("
            XL2C_Quote T.child, args, nesting+2, wildcard
            IO.Write ", "
            if T.opening = PR.INDENT_MARKER then
               IO.Write """I+"", ""I-"""
            else
               IO.Write '"', T.opening, """, """, T.closing, '"'
            IO.Write ")"

        if form.kind = PT.xlPREFIX then
            T : PT.prefix_tree := PT.prefix_tree(form)
            IO.WriteLn "xl::parser::tree::newprefix("
            XL2C_Quote T.left, args, nesting+2, wildcard
            IO.WriteLn ","
            XL2C_Quote T.right, args, nesting+2, wildcard
            IO.WriteLn ")"

        if form.kind = PT.xlINFIX then
            T : PT.infix_tree := PT.infix_tree(form)
            IO.Write "xl::parser::tree::newinfix("
            if T.name = ASCII.CR then
                IO.WriteLn "xl::textio::encoding::ascii::cr,"
            else
                IO.WriteLn "text(", '"', T.name, '"', "),"
            XL2C_Quote T.left, args, nesting+2, wildcard
            IO.WriteLn ","
            XL2C_Quote T.right, args, nesting+2, wildcard
            IO.WriteLn ")"


    procedure XL2C_TranslateOne (to_translate: PT.tree; ToMatch : PT.tree; Body : PT.tree; Condition : PT.tree := nil) is
    // ------------------------------------------------------------------------
    //    Translate one 'when' clause in translate statements
    // ------------------------------------------------------------------------
        args : args_map
        loop_index += 1

        IO.WriteLn "{"
        IO.WriteLn "static xl::parser::tree::tree ref", loop_index, "="
        XL2C_Quote ToMatch, args, 2, true
        IO.WriteLn ";"
        IO.WriteLn "xl::parser::tree::treemap args", loop_index, ";"
        IO.Write "if (xl::parser::tree::matches("
        XL2C to_translate
        IO.Writeln ", ref", loop_index, ", args", loop_index, ")) {"

        N : text
        for N in args loop
            Nm : text := XLNormalize(N)
            IO.Write "xl::parser::tree::tree ", Nm
            IO.WriteLn " = args",loop_index,"[text(", '"', Nm,'"', ")];"
            IO.WriteLn "XLDeref(", Nm, ");"

        if Condition <> nil then
            IO.Write "if ("
            XL2C Condition
            IO.WriteLn ") {"
        XL2C_Body Body, true

        IO.WriteLn "XLtranslateDone = true;"
        IO.Writeln "break;"
        IO.WriteLn "}}"
        if Condition <> nil then
            IO.WriteLn "}"



    procedure XL2C_Translate (to_translate : PT.tree; how : PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a translate statement
    // ------------------------------------------------------------------------

        translate how
           when
              when
                  'ToMatch'
              where
                  'Condition'
              then
                  'Body'
           then
              Xl2C_TranslateOne to_translate, ToMatch, Body, Condition
           when
              when ('ToMatch') where 'Condition' then
                  'Body'
           then
              Xl2C_TranslateOne to_translate, ToMatch, Body, Condition

           when
              when
                  'ToMatch'
              then
                  'Body'
           then
              Xl2C_TranslateOne to_translate, ToMatch, Body
           when
              when ('ToMatch') then
                  'Body'
           then
              Xl2C_TranslateOne to_translate, ToMatch, Body

           when
               'A' else 'B'
           then
               XL2C_Translate to_translate, A
               IO.WriteLn "if (!XLtranslateDone) {"
               XL2C_Stmt B
               IO.WriteLn "}"

           when
              'A'
              'B'
           then
              XL2C_Translate to_translate, A
              XL2C_Translate to_translate, B

           else
              IO.Writeln "*** Ungrokable 'translate'"
              IO.WriteLn IO.show_debug, "[[", how, "]]"


    procedure XL2C_SemanticsTranslationOne(Name : PT.name_tree; ToMatch : PT.tree; Body : PT.tree; Condition : PT.tree := nil) is
    // ------------------------------------------------------------------------
    //   One 'when' clause in translations
    // ------------------------------------------------------------------------
        args : args_map
        NmT : text := XLNormalize(Name.value)
        first : boolean := false
        loop_index += 1

        // Local declaration for recursion
        if count(translations, NmT) = 0 then
            IO.WriteLn "xl::parser::tree::tree ", NmT
            IO.WriteLn " (xl::parser::tree::tree input) {"
            IO.WriteLn "  return xl::symbols::lookuprewrite("
            IO.WriteLn "      xl::translator::context,"
            IO.WriteLn "      """, NmT, ""","
            IO.WriteLn "      input);"
            IO.WriteLn "}"
            first := true

        // Record that we had a translation for that name
        translations [NmT] := 1

        // Write the initialization of the symbol table
        old_stdout : IO.output_file := IO.standard_output
        new_stdout : IO.output_string_stream := IO.open_string_stream()
        IO.standard_output := new_stdout

        IO.WriteLn "{"
        IO.WriteLn "static xl::parser::tree::tree ref ="
        XL2C_Quote ToMatch, args, 2, true
        IO.WriteLn ";"
        IO.WriteLn "xl::symbols::rewrite rew ="
        IO.WriteLn "new xl::symbols::rewritedata;"
        IO.WriteLn "rew->referenceform = ref;"
        if Condition <> nil then
            IO.WriteLn "rew->scoreadjust = ", current_module, "scoreadjust_", loop_index, ";"
        else
            IO.WriteLn "rew->scoreadjust = 0;"
        IO.Write   "rew->translator = "
        IO.WriteLn current_module, "translator_", loop_index, ";"
        IO.WriteLn "xl::symbols::enterrewrite("
        IO.WriteLn "  xl::translator::context,"
        IO.WriteLn "  ", '"', NmT, '"', ","
        IO.WriteLn "  rew);"
        if first then
            IO.WriteLn "xl::symbols::setinteger("
            IO.WriteLn "  xl::translator::context,"
            IO.WriteLn "  ", '"', NmT, ".pragma", '"', ","
            IO.WriteLn "  1);"
        IO.WriteLn "}"

        semantics_translations_init+=IO.close_string_stream(new_stdout)
        IO.standard_output := old_stdout

        // Write the callback function
        IO.WriteLn "xl::parser::tree::tree translator_", loop_index
        IO.WriteLn "  (xl::parser::tree::tree input,"
        IO.WriteLn "   xl::parser::tree::tree scope,"
        IO.WriteLn "   xl::symbols::rewrite info,"
        IO.WriteLn "   xl::parser::tree::treemap &Args) {"

        N : text
        for N in args loop
            Nm : text := XLNormalize(N)
            IO.Write "xl::parser::tree::tree ", Nm
            IO.WriteLn " = Args[text(", '"',Nm,'"', ")];"
            IO.WriteLn "XLDeref(", Nm, ");"
        IO.WriteLn "xl::parser::tree::tree result = input;"

        XL2C_Body Body, true
        IO.WriteLn "return result;"
        IO.WriteLn "}"

        // Write the score adjust function if necessary
        if Condition <> nil then
            IO.WriteLn "int scoreadjust_", loop_index, "("
            IO.WriteLn "xl::parser::tree::tree Test,"
            IO.WriteLn "xl::symbols::rewrite Info,"
            IO.WriteLn "xl::parser::tree::treemap &Args,"
            IO.WriteLn "int Depth, int Score) {"

            N : text
            for N in args loop
                Nm : text := XLNormalize(N)
                IO.Write "xl::parser::tree::tree ", Nm
                IO.WriteLn " = Args[text(", '"',Nm,'"', ")];"
                IO.WriteLn "XLDeref(", Nm, ");"
            IO.WriteLn "int result = Score + 0x80;"
            IO.Write "if (!("
            XL2C Condition
            IO.WriteLn ")) result = 0;"
            IO.WriteLn "return result;"
            IO.WriteLn "}"


    procedure XL2C_SemanticsTranslation (Name : PT.name_tree; How: PT.tree) is
    // ------------------------------------------------------------------------
    //    Translate a semantics_translation statement
    // ------------------------------------------------------------------------

        // Translate the statement itself
        translate How
           when
              when
                  'ToMatch'
              where
                  'Condition'
              then
                  'Body'
           then
               XL2C_SemanticsTranslationOne Name, ToMatch, Body, Condition
           when
              when ('ToMatch') where 'Condition' then
                  'Body'
           then
               XL2C_SemanticsTranslationOne Name, ToMatch, Body, Condition

           when
              when
                  'ToMatch'
              then
                  'Body'
           then
               XL2C_SemanticsTranslationOne Name, ToMatch, Body
           when
              when ('ToMatch') then
                  'Body'
           then
               XL2C_SemanticsTranslationOne Name, ToMatch, Body

           when
              'A'
              'B'
           then
              XL2C_SemanticsTranslation Name, A
              XL2C_SemanticsTranslation Name, B

           else
              IO.Writeln "*** Ungrokable 'semantics_translation'"
              IO.WriteLn IO.show_debug, "[[", how, "]]"


    procedure XL2C_EarlyInit (What : PT.tree) is
    // ------------------------------------------------------------------------
    //    Emit the code for early initialization
    // ------------------------------------------------------------------------

        // Write the call to the initialization function
        old_stdout : IO.output_file := IO.standard_output
        new_stdout : IO.output_string_stream := IO.open_string_stream()
        IO.standard_output := new_stdout
        loop_index += 1
        IO.WriteLn current_module, "init_", loop_index, "();"
        initializations += IO.close_string_stream(new_stdout)
        IO.standard_output := old_stdout

        // Write the initialization code in said function
        IO.WriteLn "void init_", loop_index, "() {"
        XL2C_Body What, true
        IO.WriteLn "}"


    procedure XL2C_LateCleanup (What : PT.tree) is
    // ------------------------------------------------------------------------
    //    Emit the code for late cleanup
    // ------------------------------------------------------------------------

        // Write the call to the initialization function
        old_stdout : IO.output_file := IO.standard_output
        new_stdout : IO.output_string_stream := IO.open_string_stream()
        IO.standard_output := new_stdout
        loop_index += 1
        IO.WriteLn current_module, "term_", loop_index, "();"
        terminations += IO.close_string_stream(new_stdout)
        IO.standard_output := old_stdout

        // Write the initialization code that calls said function
        IO.WriteLn "void term_", loop_index, "() {"
        XL2C_Body What, true
        IO.WriteLn "}"
