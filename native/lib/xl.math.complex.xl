// *****************************************************************************
// xl.math.complex.xl                                                 XL project
// *****************************************************************************
//
// File description:
//
//     Implementation of complex numbers
//
//     The interface does not specify the many special cases and optimizations,
//     which are described in this file
//
//
//
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2018-2020, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

module COMPLEX[real : like NUMBER.number, angle : like ANGLE.angle] is
// ----------------------------------------------------------------------------
//    Complex numbers taking the given `real` and 'angle' types
// ----------------------------------------------------------------------------

    // Imaginary unit
    i                           as complex      is cartesian(real 0, real 1)
    square_angle                as angle        is arccos(angle(0))
    half_circle                 as angle        is 2 * square_angle
    full_circle                 as angle        is 4 * square_angle

    //  Multiplication by i (e.g. to accelerate exp(Z*i))
    Z:cartesian * [[i]]         as cartesian    is cartesian(Z.Im, -Z.Re)
    Z:polar     * [[i]]         as polar        is polar(Z.Mod, Z.Arg + square_angle)
    [[i]]       * Z:cartesian   as cartesian    is cartesian(Z.Im, -Z.Re)
    [[i]]       * Z:polar       as polar        is polar(Z.Mod, Z.Arg + square_angle)

    // Implicit conversion between the representations
    Z:cartesian                 as polar        is polar(mod Z, arg Z)
    Z:polar                     as cartesian    is cartesian(re Z, im Z)
    X:real                      as cartesian    is cartesian(X, real 0)
    X:real                      as polar        is polar(X, real 0)
    X:real                      as complex      is cartesian(X, real 0)
    X:natural                   as cartesian    is cartesian(real X, real 0)
    X:natural                   as polar        is polar(real X, real 0)
    X:natural                   as complex      is cartesian(real X, real 0)
`
    // Special operations that can be optimized with one real operand
    Z:cartesian + X:real        as cartesian    is cartesian(Z.Re + X, Z.Im)
    Z:cartesian - X:real        as cartesian    is cartesian(Z.Re - X, Z.Im)
    Z:cartesian * X:real        as cartesian    is cartesian(Z.Re * X, Z.Im * X)
    Z:cartesian / X:real        as cartesian    when X ≠ 0 is cartesian(Z.Re / X, Z.Im / X)
    Z:cartesian / X:real        as error        when X =  0 is error "Divide complex by zero"
    X:real      + Z:cartesian   as cartesian    is cartesian(X + Z.Re, Z.Im)
    X:real      - Z:cartesian   as cartesian    is cartesian(X - Z.Re, -Z.Im)
    X:real      * Z:cartesian   as cartesian    is cartesian(X * Z.Re, X * Z.Im)
    X:real      / Z:cartesian   as cartesian    when Z ≠ 0 is
        Denominator is Z.Re^2 + Z.Im^2
        cartesian(X*Z.Re, -X*Z.Im) / Denominator
    X:real      / Z:cartesian   as cartesian    when Z =  0 is error "Divide by complex zero"

    // In polar form, only multiplication and division are faster
    Z:polar     * X:real        as polar        is polar(Z.Mod * X, Z.Arg)
    Z:polar     / X:real        as polar        when X ≠ 0      is polar(Z.Mod / X, Z.Arg)
    Z:polar     / X:real        as error        when X = 0      is error "Divide complex by zero"
    X:real      * Z:polar       as polar        is polar(X * Z.Mod, Z.Arg)
    X:real      / Z:polar       as polar        when X ≠ 0      is polar(X / Z.Mod, -Z.Arg)
    X:real      / Z:polar       as error        when X = 0      is error "Divide by complex zero"

    // Basic arithmetic in cartesian form
    X:cartesian + Y:cartesian   as cartesian    is cartesian(X.Re + Y.Re, X.Im + Y.Im)
    X:cartesian - Y:cartesian   as cartesian    is cartesian(X.Re - Y.Re, X.Im - Y.Im)
    X:cartesian * Y:cartesian   as cartesian    is cartesian (Z1.Re * Z2.Re - Z1.Im * Z2.Im,
                                                              Z1.Re * Z2.Im + Z1.Im * Z2.Re)
    X:cartesian / Y:cartesian   as cartesian    is
        Numerator   is cartesian(Z1.Re*Z2.Re + Z1.Im*Z2.Im, Z1.Im*Z2.Re - Z1.Re*Z2.Im)
        Denominator is Z2.Re^2 + Z2.Im^2
        Numerator / Denominator

    +X:cartesian                as cartesian    is X
    -X:cartesian                as cartesian    is cartesian(-X.Re, -X.Im)
    ~X:cartesian                as cartesian    is cartesian(X.Re, -X.Im)

    // Basic arithmetic in polar form
    X:polar     * Y:polar       as polar        is polar(X.Mod * Y.Mod, Y.Arg + Y.Arg)
    X:polar     / Y:polar       as polar        when Y.Arg ≠ 0 is polar(X.Mod/Y.Mod, X.Arg-Y.arg)
    X:polar     / Y:polar       as error        when Y.Arg = 0 is error "Divide by zero, polar form"
    +X:polar                    as polar        is X
    -X:polar                    as polar        is polar(X.Mod, (X.Arg + half_circle) mod full_circle)
    ~X:polar                    as polar        is polar(X.Mod, -X.Arg)

    // Prefix form for field access
    re          Z:cartesian     as real         is Z.Re
    re          Z:polar         as real         is Z.Mod * cos(Z.Arg)
    im          Z:cartesian     as real         is Z.Im
    im          Z:polar         as real         is Z.Mod * sin(Z.Arg)
    mod         Z:cartesian     as real         is sqrt(Z.Re^2 + Z.Im^2)
    mod         Z:polar         as real         is Z.Mod
    arg         Z:cartesian     as real         is arctan(Z.Im, Z.Re)
    arg         Z:polar         as real         is Z.Arg

    // Comparisons
    X:cartesian = Y:cartesian   as boolean      is X.Re = Y.Re and X.Im = Y.Im
    X:cartesian < Y:cartesian   as boolean      is X.Re < Y.Re or (X.Re = Y.Re and X.Im < Y.Im)

    // Some elementaty functions on complex numbers
    sqrt        Z:polar         as polar        is polar(sqrt(Z.Arg), Z.Im / 2)
    exp         Z:cartesian     as polar        is polar(exp(Z.Re), Z.Im)
    ln          Z:polar         as cartesian    is cartesian(ln(Z.Arg), Z.Mod)

    sin         Z:cartesian     as polar        is (exp(i*Z) - exp(-i*Z)) / (2*i)
    cos         Z:cartesian     as polar        is (exp(i*Z) + exp(-i*Z)) / 2
    tan         Z:cartesian     as polar        is (sin Z / cos Z)
    arcsin      Z:polar         as cartesian    is (ln(i * Z + sqrt(1-Z&2)) / i)
    arccos      Z:polar         as cartesian    is (ln(Z + i * sqrt(1-Z^2)) / i)
    arctan      Z:polar         as cartesian    is (ln((i-Z)/(i+Z)) / (2*i))

    sinh        Z:cartesian     as polar        is ((exp(Z) - exp(-Z)) / 2)
    cosh        Z:cartesian     as polar        is ((exp(Z) + exp(-Z)) / 2)
    tanh        Z:cartesian     as polar        is
        exp_p is exp Z
        exp_m is exp(-Z)
        (exp_p - exp_m) / (exp_p + exp_m)
    arcsinh     Z:polar         as cartesian    is ln(Z + sqrt(Z^2 + 1))
    arccosh     Z:polar         as cartesian    is ln(Z + sqrt(Z^2 - 1))
    arctanh     Z:polar         as cartesian    is ln((Z+1) / (Z-1)) / 2

    use XL.TEXT_IO
    to write    Z:cartesian                     is write format("(%1, %2)", Z.Re, Z.Im)
    to write    Z:polar                         is write format("(%1∠%2)", Z.Mod, Z.Arg)






    // Imaginary unit, which can exist in imaginary, cartesian or polar form
    i                           as imaginary    is imaginary 1
    i                           as cartesian    is cartesian(0, 1)
    i                           as polar
    j                           is i

    // Angle constant we use to identify imaginary axis
    quarter                     is angle(pi/2)
    half                        is angle(pi)

    // Creating an imaginary
    Im:real [[i]]               as imaginary    is imaginary(Im)
    [[i]] Im:real               as imaginary    is imaginary(Im)

    // Shortcut notation for cartesian notation like `2 + 3i`
    Re:real + Im:imaginary      as cartesian    is cartesian(Re, Im.Im)

    // Shortcut for polar notation like `2 ∠ 180°`
    Mod:real ∠ Arg:angle        as polar        is polar(Mod, Arg)

    // Shortcut for multiplication by i like `exp (i Z)
    Z:complex [[i]]             as complex      is Z * i
    [[i]] Z:complex             is Z i

    // Optimize cases of multiplication by i
    Z:imaginary * [[i]]         as real         is -Z.Im
    Z:cartesian * [[i]]         as cartesian    is cartesian(-Z.Im, Z.Re)
    Z:polar * [[i]]             as polar        is polar(Z.Mod, Z.Arg + quarter)

    // Implicit conversion between the representations
    X:real when X=0             as imaginary    is imaginary(0)
    X:real                      as cartesian    is cartesian(X, 0)
    X:real                      as polar        is polar(X, 0)
    Z:imaginary when Z.Im=0     as real         is real(0)
    Z:imaginary                 as cartesian    is cartesian(0, Z.Im)
    Z:imaginary                 as polar        is polar(Z.Im, quarter)
    Z:cartesian when Z.Im=0     as real         is real(Z.Re)
    Z:cartesian when Z.Re=0     as imaginary    is imaginary(Z.Im)
    Z:cartesian                 as polar
    Z:polar when Z.Arg=0        as real         is real(Z.Mod)
    Z:polar when Z.Arg=half     as real         is real(-Z.Mod)
    Z:polar when Z.Arg=quarter  as imaginary    is imaginary(Z.Mod)
    Z:polar when Z.Arg=-quarter as imaginary    is imaginary(-Z.Mod)
    Z:polar                     as cartesian

    // Implicit conversion from anything that implicitly converts to [real]
    // This is necessary for [Z:=2] if [real] is floating point
    X:implicit[real]            as cartesian    is cartesian(real(X), 0)
    X:implicit[real]            as polar        is polar(real(X), 0)
`
    // Special operations that can be optimized with one real operand
    Z:cartesian + X:real        as cartesian
    Z:cartesian - X:real        as cartesian
    Z:cartesian * X:real        as cartesian
    Z:cartesian / X:real        as cartesian    when X ≠ 0
    Z:cartesian / X:real        as error        when X = 0
    X:real      + Z:cartesian   as cartesian
    X:real      - Z:cartesian   as cartesian
    X:real      * Z:cartesian   as cartesian
    X:real      / Z:cartesian   as cartesian    when Z ≠ 0
    X:real      / Z:cartesian   as error        when Z = 0

    // In polar form, only multiplication and division are faster
    Z:polar     * X:real        as polar
    Z:polar     / X:real        as polar        when X ≠ 0
    Z:polar     / X:real        as error        when X = 0
    X:real      * Z:polar       as polar
    X:real      / Z:polar       as polar        when X ≠ 0
    X:real      / Z:polar       as error        when X = 0

    // Basic arithmetic in cartesian form
    X:cartesian + Y:cartesian   as cartesian
    X:cartesian - Y:cartesian   as cartesian
    X:cartesian * Y:cartesian   as cartesian
    X:cartesian / Y:cartesian   as cartesian    when X ≠ 0
    X:cartesian / Y:cartesian   as error        when X = 0
    +X:cartesian                as cartesian
    -X:cartesian                as cartesian
    ~X:cartesian                as cartesian    // Conjugate
    conjugate X:cartesian       as cartesian    is ~X

    // Basic arithmetic in polar form
    X:polar     * Y:polar       as polar
    X:polar     / Y:polar       as polar        when Y.Arg ≠ 0
    X:polar     / Y:polar       as error        when Y.Arg = 0
    +X:polar                    as polar
    -X:polar                    as polar
    ~X:polar                    as polar        // Conjugate
    conjugate X:polar           as polar        is ~X

    // Prefix form for real and imaginary part without whole conversion
    re          Z:cartesian     as real         is Z.Re
    re          Z:polar         as real
    im          Z:cartesian     as real         is Z.Im
    im          Z:polar         as real
    mod         Z:cartesian     as real
    mod         Z:polar         as real         is Z.Mod
    arg         Z:cartesian     as real
    arg         Z:polar         as real         is Z.Arg

    // Equality
    X:cartesian = Y:cartesian   as boolean
    X:polar     = Y:polar       as boolean

    // Total order
    // The < operator is a lexicographic order, required for some containers
    // For consistency, it is only defined on the cartesian form, where it
    // matches the order on real values
    X:cartesian < Y:cartesian   as boolean

    // Some elementaty functions on complex numbers
    abs         Z: complex      as real         is mod Z
    sqrt        Z:polar         as polar
    exp         Z:cartesian     as polar
    ln          Z:polar         as cartesian when Z.Arg ≠ 0

    Z:cartesian ^ N:natural     as cartesian
    X:polar     ^ Y:cartesian   as polar

    sin         Z:cartesian     as polar
    cos         Z:cartesian     as polar
    tan         Z:cartesian     as polar
    arcsin      Z:polar         as cartesian
    arccos      Z:polar         as cartesian
    arctan      Z:polar         as cartesian

    sinh        Z:cartesian     as polar
    cosh        Z:cartesian     as polar
    tanh        Z:cartesian     as polar
    arcsinh     Z:polar         as cartesian
    arccosh     Z:polar         as cartesian
    arctanh     Z:polar         as cartesian

    // Basic I/O operations
    to write    Z:cartesian     as ok
    to write    Z:polar         as ok
    to read     Z:out cartesian as ok
    to read     Z:out polar     as ok
