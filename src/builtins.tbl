// *****************************************************************************
// interpreter.tbl                                                    XL project
// *****************************************************************************
//
// File description:
//
//     Opcode interpretation
//
//     Normally, opcodes defined here should match those in llvm.tbl
//     although there is strictly speaking no reason other than
//     the convenience for maintaining builtins.xl
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2015-2019, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

// ============================================================================
//
//   Reserved names
//
// ============================================================================

NAME(self)                      // Must come first, used in Define(...)
NAME(nil)
NAME(true)
NAME(false)
NAME(error)
NAME(matching)
NAME(builtin)
NAME(lambda)



// ============================================================================
//
//    Basic types
//
// ============================================================================

TYPE(tree,      return value)
TYPE(natural,   return value->AsNatural())
TYPE(real,      return value->AsReal())
TYPE(text,      return value->AsText())
TYPE(character,
     if (Text *text = value->AsText())
         if (text->IsCharacter())
             return text;
     return nullptr)
TYPE(symbol,    return value->AsName())
TYPE(name,
     if (Name *name = value->AsName())
         if (name->IsName())
             return name;
     return nullptr)
TYPE(operator,
     if (Name *name = value->AsName())
         if (name->IsOperator())
             return name;
     return nullptr)
TYPE(boolean,
     if (Name *name = value->AsName())
         if (name->IsBoolean())
             return name->value == "true" ? xl_true : xl_false;
     return nullptr)
TYPE(block,     return value->AsBlock())
TYPE(infix,     return value->AsInfix())
TYPE(prefix,    return value->AsPrefix())
TYPE(postfix,   return value->AsPostfix())
TYPE(scope,     return value->As<Scope>())
TYPE(declaration, return IsDeclaration(value))



// ============================================================================
//
//   Sized types (REVISIT: Necessary for compatibility with compiler)
//
// ============================================================================

#define IN_RANGE(X, CType)                              \
        ((X) >= std::numeric_limits<CType>::min() &&    \
         (X) <= std::numeric_limits<CType>::max())

#define NATURAL_TYPE(Name, CType)               \
    TYPE(Name,                                  \
         if (Natural *nat = value->AsNatural()) \
             if (IN_RANGE(nat->value, CType))   \
                 return nat;                    \
         return nullptr)

#define INTEGER_TYPE(Name, CType)                               \
    TYPE(Name,                                                  \
         if (Natural *nat = value->AsNatural())                 \
             if (IN_RANGE((longlong) nat->value, CType))        \
                 return nat;                                    \
         return nullptr)

#define REAL_TYPE(Name, CType)                          \
    TYPE(Name,                                          \
         if (Real *nat = value->AsReal())               \
         {                                              \
             CType tmp = nat->value;                    \
             if (tmp != nat->value)                     \
                 return new Real(tmp, nat->Position()); \
             return nat;                                \
         }                                              \
         return nullptr)


NATURAL_TYPE(natural8,  uint8_t)
NATURAL_TYPE(natural16, uint16_t)
NATURAL_TYPE(natural32, uint32_t)
NATURAL_TYPE(natural64, uint64_t)

TYPE(integer, return value->AsNatural())
INTEGER_TYPE(integer8,  int8_t)
INTEGER_TYPE(integer16, int16_t)
INTEGER_TYPE(integer32, int32_t)
INTEGER_TYPE(integer64, int64_t)

REAL_TYPE(real, double)
#ifdef HAVE_FLOAT16
REAL_TYPE(real16, _Float16)
#endif // HAVE_FLOAT16
REAL_TYPE(real32, float)
REAL_TYPE(real64, double)


// ============================================================================
//
//   Arithmetic
//
// ============================================================================

// Binary arithmetic
BINARY_OP(Add,     Natural, Natural, Natural,      R_INT ( LEFT +  RIGHT))
BINARY_OP(FAdd,    Real,    Real,    Real,         R_REAL( LEFT +  RIGHT))
BINARY_OP(Sub,     Natural, Natural, Natural,      R_INT ( LEFT -  RIGHT))
BINARY_OP(FSub,    Real,    Real,    Real,         R_REAL( LEFT -  RIGHT))
BINARY_OP(Mul,     Natural, Natural, Natural,      R_INT ( LEFT *  RIGHT))
BINARY_OP(FMul,    Real,    Real,    Real,         R_REAL( LEFT *  RIGHT))
BINARY_OP(UDiv,    Natural, Natural, Natural, DIV0;R_INT ( LEFT /  RIGHT))
BINARY_OP(SDiv,    Natural, Natural, Natural, DIV0;R_INT (SLEFT /  RIGHT))
BINARY_OP(FDiv,    Real,    Real,    Real,    DIV0;R_REAL( LEFT /  RIGHT))
BINARY_OP(URem,    Natural, Natural, Natural, DIV0;R_INT (ULEFT % URIGHT))
BINARY_OP(SRem,    Natural, Natural, Natural, DIV0;R_INT ( LEFT %  RIGHT))
BINARY_OP(UMod,    Natural, Natural, Natural, DIV0;R_INT (ULEFT % URIGHT))
BINARY_OP(FRem,    Real,    Real,    Real,    DIV0;R_INT (fmod(LEFT,RIGHT)))
BINARY_OP(Shl,     Natural, Natural, Natural,      R_INT ( LEFT << RIGHT))
BINARY_OP(LShr,    Natural, Natural, Natural,      R_INT (ULEFT >> RIGHT))
BINARY_OP(AShr,    Natural, Natural, Natural,      R_INT (SLEFT >> RIGHT))
BINARY_OP(And,     Natural, Natural, Natural,      R_INT ( LEFT &  RIGHT))
BINARY_OP(Or,      Natural, Natural, Natural,      R_INT ( LEFT |  RIGHT))
BINARY_OP(Xor,     Natural, Natural, Natural,      R_INT ( LEFT ^  RIGHT))

// Unary operators
UNARY_OP(Neg,      Natural, Natural,               R_INT (-SVALUE))
UNARY_OP(FNeg,     Real,    Real,                  R_REAL(-VALUE))
UNARY_OP(Not,      Natural, Natural,               R_INT (~VALUE))

// Integer compare
BINARY_OP(ICmpEQ,  Name,    Natural, Natural,      R_BOOL( LEFT ==  RIGHT))
BINARY_OP(ICmpNE,  Name,    Natural, Natural,      R_BOOL( LEFT !=  RIGHT))
BINARY_OP(ICmpUGT, Name,    Natural, Natural,      R_BOOL(ULEFT >  URIGHT))
BINARY_OP(ICmpUGE, Name,    Natural, Natural,      R_BOOL(ULEFT >= URIGHT))
BINARY_OP(ICmpULT, Name,    Natural, Natural,      R_BOOL(ULEFT <  URIGHT))
BINARY_OP(ICmpULE, Name,    Natural, Natural,      R_BOOL(ULEFT <= URIGHT))
BINARY_OP(ICmpSGT, Name,    Natural, Natural,      R_BOOL(SLEFT >  SRIGHT))
BINARY_OP(ICmpSGE, Name,    Natural, Natural,      R_BOOL(SLEFT >= SRIGHT))
BINARY_OP(ICmpSLT, Name,    Natural, Natural,      R_BOOL(SLEFT <  SRIGHT))
BINARY_OP(ICmpSLE, Name,    Natural, Natural,      R_BOOL(SLEFT <= SRIGHT))

// Floating-point compare
BINARY_OP(FCmpOEQ, Name,    Real,    Real,         R_BOOL(LEFT == RIGHT))
BINARY_OP(FCmpONE, Name,    Real,    Real,         R_BOOL(LEFT != RIGHT))
BINARY_OP(FCmpOGT, Name,    Real,    Real,         R_BOOL(LEFT >  RIGHT))
BINARY_OP(FCmpOGE, Name,    Real,    Real,         R_BOOL(LEFT >= RIGHT))
BINARY_OP(FCmpOLT, Name,    Real,    Real,         R_BOOL(LEFT <  RIGHT))
BINARY_OP(FCmpOLE, Name,    Real,    Real,         R_BOOL(LEFT <= RIGHT))

BINARY_OP(BCmpEQ,  Name,    Name,    Name,         R_BOOL(LEFT_B ==  RIGHT_B))
BINARY_OP(BCmpNE,  Name,    Name,    Name,         R_BOOL(LEFT_B !=  RIGHT_B))
BINARY_OP(BCmpGT,  Name,    Name,    Name,         R_BOOL(LEFT_B >   RIGHT_B))
BINARY_OP(BCmpGE,  Name,    Name,    Name,         R_BOOL(LEFT_B >=  RIGHT_B))
BINARY_OP(BCmpLT,  Name,    Name,    Name,         R_BOOL(LEFT_B <   RIGHT_B))
BINARY_OP(BCmpLE,  Name,    Name,    Name,         R_BOOL(LEFT_B <=  RIGHT_B))
BINARY_OP(BAnd,    Name,    Name,    Name,         R_BOOL(LEFT_B and RIGHT_B))
BINARY_OP(BOr,     Name,    Name,    Name,         R_BOOL(LEFT_B or  RIGHT_B))
BINARY_OP(BXor,    Name,    Name,    Name,         R_BOOL(LEFT_B xor RIGHT_B))
UNARY_OP(BNot,     Name,    Name,                  R_BOOL(not VALUE_B))


// ============================================================================
//
//   Special opcodes that perform XL-specific operations
//
// ============================================================================

UNARY_OP(TreeKind,         Natural, Tree,          R_INT (value->Kind()))
UNARY_OP(PrefixLeft,       Tree,    Prefix,        return value->left)
UNARY_OP(PrefixRight,      Tree,    Prefix,        return value->right)
UNARY_OP(PostfixLeft,      Tree,    Postfix,       return value->left)
UNARY_OP(PostfixRight,     Tree,    Postfix,       return value->right)
UNARY_OP(InfixLeft,        Tree,    Infix,         return value->left)
UNARY_OP(InfixRight,       Tree,    Infix,         return value->right)
UNARY_OP(InfixName,        Text,    Infix,         R_TEXT(value->name))
UNARY_OP(TextOpening,      Text,    Text,          R_TEXT(value->opening))
UNARY_OP(TextClosing,      Text,    Text,          R_TEXT(value->closing))
UNARY_OP(BlockChild,       Tree,    Block,         return value->child)
UNARY_OP(BlockOpening,     Text,    Block,         R_TEXT(value->opening))
UNARY_OP(BlockClosing,     Text,    Block,         R_TEXT(value->closing))



// ============================================================================
//
//   Undefine the configuration macros
//
// ============================================================================

#undef UNARY_OP
#undef BINARY_OP
#undef TYPE
#undef NAME
#undef NATURAL_TYPE
#undef INTEGER_TYPE
#undef REAL_TYPE
