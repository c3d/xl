// *****************************************************************************
// builtins.tbl                                                       XL project
// *****************************************************************************
//
// File description:
//
//     Opcode interpretation
//
//     Normally, opcodes defined here should match those in llvm.tbl
//     although there is strictly speaking no reason other than
//     the convenience for maintaining builtins.xl
//
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2020-2021, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

// ============================================================================
//
//   Reserved names
//
// ============================================================================
//   The order below matters. 'self' must come first, because other names
//   are defined as [foo is self]

NAME(self)                      // Must come first, used in Define(...)
NAME(true)
NAME(false)
NAME(error)
NAME(matching)
NAME(builtin)
NAME(lambda)
NAME(variable)



// ============================================================================
//
//    Basic types
//
// ============================================================================

// Unevaluated types do not cause evaluation
TYPE(tree,              R_TYPE(TYPE_TREE))
TYPE(scope,             R_TYPE(TYPE_TREE->As<Scope>()))
TYPE(closure,           R_TYPE(TYPE_CLOSURE))
TYPE(definition,        R_TYPE(IsDefinition(TYPE_TREE)))

// Types that evaluate only if they don't initially match
#define MATCH_OR_EVAL(TypeName, TypeClass, TypeCondition)               \
    TYPE(TypeName,                                                      \
         Tree *tree = TYPE_TREE;                                        \
         record(typecheck, "Builtin " #TypeName " %t", tree);           \
         if (TypeClass *typed = tree->As##TypeClass())                  \
             if (TypeCondition)                                         \
                 R_TYPE(typed);                                         \
         record(typecheck, "Evaluate %t as " #TypeName, tree);          \
         if (Name *name = tree->AsName())                               \
             if (TypeClass *typed = TYPE_NAMED->As##TypeClass())        \
                 if ((TypeCondition) && name == name)                   \
                     R_TYPE(typed);                                     \
         record(typecheck, "No " #TypeName " for %t", tree);            \
         R_TYPE(nullptr))
MATCH_OR_EVAL(block,    Block,  true)
MATCH_OR_EVAL(infix,    Infix,  true)
MATCH_OR_EVAL(prefix,   Prefix, true)
MATCH_OR_EVAL(postfix,  Postfix,true)
MATCH_OR_EVAL(symbol,   Name,   true)
MATCH_OR_EVAL(name,     Name,   typed->IsName())
MATCH_OR_EVAL(operator, Name,   typed->IsOperator())

// Other types need to evaluate their arugment
TYPE(value,     R_TYPE(TYPE_VALUE))
TYPE(natural,                                                   \
     if (Natural *nat = TYPE_VALUE->AsNatural())                \
     {                                                          \
         if (nat->IsSigned() && (longlong) nat->value < 0)      \
             R_TYPE(nullptr);                                   \
         R_TYPE(nat->MakeUnsigned());                           \
     }                                                          \
     R_TYPE(nullptr))
TYPE(text,      R_TYPE(TYPE_VALUE->AsText()))
TYPE(character,
     if (Text *text = TYPE_VALUE->AsText())
         if (text->IsCharacter())
             R_TYPE(text);
     R_TYPE(nullptr))
TYPE(boolean,
     if (Name *name = TYPE_VALUE->AsName())
         if (name->IsBoolean())
             R_TYPE(name->value == "true" ? xl_true : xl_false);
     R_TYPE(nullptr))



// ============================================================================
//
//   Sized types (REVISIT: Necessary for compatibility with compiler)
//
// ============================================================================

#define IN_RANGE(X, CType)                              \
    ((X) >= std::numeric_limits<CType>::min() &&        \
     (X) <= std::numeric_limits<CType>::max())

#define NATURAL_TYPE(Name, CType)                               \
    TYPE(Name,                                                  \
         if (Natural *nat = TYPE_VALUE->AsNatural())            \
             if (IN_RANGE(nat->value, CType))                   \
                 R_TYPE(nat->MakeUnsigned());                   \
         R_TYPE(nullptr))

#define INTEGER_TYPE(Name, CType)                               \
    TYPE(Name,                                                  \
         if (Natural *nat = TYPE_VALUE->AsNatural())            \
             if (IN_RANGE((longlong) nat->value, CType))        \
                 R_TYPE(nat->MakeSigned());                     \
         R_TYPE(nullptr))

#define REAL_TYPE(Name, CType)                                  \
    TYPE(Name,                                                  \
         Tree *typed = TYPE_VALUE;                              \
         if (Real *real = typed->AsReal())                      \
         {                                                      \
             CType tmp = real->value;                           \
             if (tmp != real->value)                            \
                 R_TYPE(new Real(tmp, real->Position()));       \
             R_TYPE(real);                                      \
         }                                                      \
         if (Natural *nat = typed->AsNatural())                 \
         {                                                      \
             CType tmp = (long long) nat->value;                \
             R_TYPE(new Real(tmp, nat->Position()));            \
         }                                                      \
         R_TYPE(nullptr))

NATURAL_TYPE(natural8,  uint8_t)
NATURAL_TYPE(natural16, uint16_t)
NATURAL_TYPE(natural32, uint32_t)
NATURAL_TYPE(natural64, uint64_t)

TYPE(integer,                                                           \
     if (Natural *nat = TYPE_VALUE->AsNatural())                        \
     {                                                                  \
         if (!nat->IsSigned() && (longlong) nat->value < 0)             \
             R_TYPE(nullptr);                                           \
         R_TYPE(nat->MakeSigned());                                     \
     }                                                                  \
     R_TYPE(nullptr))
INTEGER_TYPE(integer8,  int8_t)
INTEGER_TYPE(integer16, int16_t)
INTEGER_TYPE(integer32, int32_t)
INTEGER_TYPE(integer64, int64_t)

REAL_TYPE(real, double)
#ifdef HAVE_FLOAT16
REAL_TYPE(real16, _Float16)
#endif // HAVE_FLOAT16
REAL_TYPE(real32, float)
REAL_TYPE(real64, double)


// ============================================================================
//
//   Arithmetic
//
// ============================================================================

#define DIVARY(Name, RT, XT, YT, Body)  BINARY(Name, RT, XT, YT, DIV0; Body)

// Binary arithmetic
BINARY(add_natural,  Natural, Natural, Natural, R_NAT (x_natural + y_natural))
BINARY(add_integer,  Natural, Natural, Natural, R_INT (x_integer + y_integer))
BINARY(add_real,     Real,    Real,    Real,    R_REAL(x_real    + y_real))
BINARY(sub_natural,  Natural, Natural, Natural, R_NAT (x_natural - y_natural))
BINARY(sub_integer,  Natural, Natural, Natural, R_INT (x_integer - y_integer))
BINARY(sub_real,     Real,    Real,    Real,    R_REAL(x_real    - y_real))
BINARY(mul_natural,  Natural, Natural, Natural, R_NAT (x_natural * y_natural))
BINARY(mul_integer,  Natural, Natural, Natural, R_INT (x_integer * y_integer))
BINARY(mul_real,     Real,    Real,    Real,    R_REAL(x_real    * y_real))
DIVARY(div_natural,  Natural, Natural, Natural, R_NAT (x_natural / y_natural))
DIVARY(div_integer,  Natural, Natural, Natural, R_INT (x_integer / y_integer))
DIVARY(div_real,     Real,    Real,    Real,    R_REAL(x_real    / y_real))
DIVARY(mod_natural,  Natural, Natural, Natural, R_NAT (x_natural % y_natural))
DIVARY(mod_integer,  Natural, Natural, Natural, R_INT (x_integer % y_integer))
DIVARY(rem_real,     Real,    Real,    Real,    R_REAL(fmod(x_real, y_real)))

BINARY(shl_natural,  Natural, Natural, Natural, R_NAT (x_natural << y_natural))
BINARY(shl_integer,  Natural, Natural, Natural, R_INT (x_integer << y_integer))
BINARY(shr_natural,  Natural, Natural, Natural, R_NAT (x_natural >> y_natural))
BINARY(shr_integer,  Natural, Natural, Natural, R_INT (x_integer >> y_integer))
BINARY(and_natural,  Natural, Natural, Natural, R_NAT (x_natural  & y_natural))
BINARY(and_integer,  Natural, Natural, Natural, R_INT (x_integer  & y_integer))
BINARY(and_boolean,  Name,    Name,    Name,    R_BOOL(x_boolean  & y_boolean))
BINARY( or_natural,  Natural, Natural, Natural, R_NAT (x_natural  | y_natural))
BINARY( or_integer,  Natural, Natural, Natural, R_INT (x_integer  | y_integer))
BINARY( or_boolean,  Name,    Name,    Name,    R_BOOL(x_boolean  | y_boolean))
BINARY(xor_natural,  Natural, Natural, Natural, R_NAT (x_natural  ^ y_natural))
BINARY(xor_integer,  Natural, Natural, Natural, R_INT (x_integer  ^ y_integer))
BINARY(xor_boolean,  Name,    Name,    Name,    R_BOOL(x_boolean  ^ y_boolean))

// Unary operators
UNARY(neg_natural,   Natural, Natural,          R_NAT (-x_natural))
UNARY(neg_integer,   Natural, Natural,          R_INT (-x_integer))
UNARY(neg_real,      Real,    Real,             R_REAL(-x_real))
UNARY(not_natural,   Natural, Natural,          R_NAT (~x_natural))
UNARY(not_integer,   Natural, Natural,          R_INT (~x_integer))
UNARY(not_boolean,   Name,    Name,             R_BOOL(!x_boolean))

// Comparisons
BINARY(eq_natural,  Name,    Natural, Natural,  R_BOOL(x_natural ==  y_natural))
BINARY(eq_integer,  Name,    Natural, Natural,  R_BOOL(x_integer ==  y_integer))
BINARY(eq_real,     Name,    Real,    Real,     R_BOOL(x_real    ==  y_real))
BINARY(eq_text,     Name,    Text,    Text,     R_BOOL(x_text    ==  y_text))
BINARY(eq_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean ==  y_boolean))

BINARY(ne_natural,  Name,    Natural, Natural,  R_BOOL(x_natural !=  y_natural))
BINARY(ne_integer,  Name,    Natural, Natural,  R_BOOL(x_integer !=  y_integer))
BINARY(ne_real,     Name,    Real,    Real,     R_BOOL(x_real    !=  y_real))
BINARY(ne_text,     Name,    Text,    Text,     R_BOOL(x_text    !=  y_text))
BINARY(ne_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean !=  y_boolean))

BINARY(lt_natural,  Name,    Natural, Natural,  R_BOOL(x_natural <   y_natural))
BINARY(lt_integer,  Name,    Natural, Natural,  R_BOOL(x_integer <   y_integer))
BINARY(lt_real,     Name,    Real,    Real,     R_BOOL(x_real    <   y_real))
BINARY(lt_text,     Name,    Text,    Text,     R_BOOL(x_text    <   y_text))
BINARY(lt_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean <   y_boolean))

BINARY(gt_natural,  Name,    Natural, Natural,  R_BOOL(x_natural >   y_natural))
BINARY(gt_integer,  Name,    Natural, Natural,  R_BOOL(x_integer >   y_integer))
BINARY(gt_real,     Name,    Real,    Real,     R_BOOL(x_real    >   y_real))
BINARY(gt_text,     Name,    Text,    Text,     R_BOOL(x_text    >   y_text))
BINARY(gt_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean >   y_boolean))

BINARY(le_natural,  Name,    Natural, Natural,  R_BOOL(x_natural <=  y_natural))
BINARY(le_integer,  Name,    Natural, Natural,  R_BOOL(x_integer <=  y_integer))
BINARY(le_real,     Name,    Real,    Real,     R_BOOL(x_real    <=  y_real))
BINARY(le_text,     Name,    Text,    Text,     R_BOOL(x_text    <=  y_text))
BINARY(le_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean <=  y_boolean))

BINARY(ge_natural,  Name,    Natural, Natural,  R_BOOL(x_natural >=  y_natural))
BINARY(ge_integer,  Name,    Natural, Natural,  R_BOOL(x_integer >=  y_integer))
BINARY(ge_real,     Name,    Real,    Real,     R_BOOL(x_real    >=  y_real))
BINARY(ge_text,     Name,    Text,    Text,     R_BOOL(x_text    >=  y_text))
BINARY(ge_boolean,  Name,    Name,    Name,     R_BOOL(x_boolean >=  y_boolean))



// ============================================================================
//
//   Conversion operators
//
// ============================================================================

UNARY(Integer2Real, Real,   Natural,            R_REAL(x_real))
UNARY(Natural2Real, Real,   Natural,            R_REAL(x_real))

// ============================================================================
//
//   Special opcodes that perform XL-specific operations
//
// ============================================================================

UNARY(TreeKind,         Natural, Tree,          R_INT (x_tree->Kind()))
UNARY(PrefixLeft,       Tree,    Prefix,        R_TYPE(x_tree->left))
UNARY(PrefixRight,      Tree,    Prefix,        R_TYPE(x_tree->right))
UNARY(PostfixLeft,      Tree,    Postfix,       R_TYPE(x_tree->left))
UNARY(PostfixRight,     Tree,    Postfix,       R_TYPE(x_tree->right))
UNARY(InfixLeft,        Tree,    Infix,         R_TYPE(x_tree->left))
UNARY(InfixRight,       Tree,    Infix,         R_TYPE(x_tree->right))
UNARY(InfixName,        Text,    Infix,         R_TEXT(x_tree->name))
UNARY(TextOpening,      Text,    Text,          R_TEXT(x_tree->opening))
UNARY(TextClosing,      Text,    Text,          R_TEXT(x_tree->closing))
UNARY(BlockChild,       Tree,    Block,         R_TYPE(x_tree->child))
UNARY(BlockOpening,     Text,    Block,         R_TEXT(x_tree->opening))
UNARY(BlockClosing,     Text,    Block,         R_TEXT(x_tree->closing))



// ============================================================================
//
//   Undefine the configuration macros
//
// ============================================================================

#undef UNARY
#undef BINARY
#undef NAME
#undef TYPE
#undef NATURAL_TYPE
#undef INTEGER_TYPE
#undef REAL_TYPE
#undef IN_RANGE
