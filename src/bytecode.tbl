// ****************************************************************************
//  bytecode.tbl                                                    XL project
// ****************************************************************************
//
//   File Description:
//
//     Definition of the bytecodes used in bytecode.cpp
//
//     Put them in a separate file mostly for convenience:
//     This is not a regular header file to be included by multiple sources.
//
//
//
//
//
// ****************************************************************************
//   (C) 2021 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
// ****************************************************************************
//   This file is part of XL.
//
//   XL is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   XL is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with XL.  If not, see <https://www.gnu.org/licenses/>.
// ****************************************************************************



// ============================================================================
//
//    Opcodes exposed as builtins
//
// ============================================================================

// Builtins are the ones exposed
#ifndef BUILTIN
#define BUILTIN(Name, Parms, Body)      OPCODE(Name, Parms, Body)
#endif

#define NATURAL_TYPE(Name, Rep)                         \
BUILTIN(Name##_typecheck, (),                           \
        Rep rep = x_natural;                            \
        if (!IsNatural(xtype) || rep != x_natural)      \
        {                                               \
            x_tree = nullptr;                           \
            TYPE(nil);                                  \
        })
#define INTEGER_TYPE(Name, Rep)                         \
BUILTIN(Name##_typecheck, (),                           \
        Rep rep = x_integer;                            \
        if (!IsInteger(xtype) || rep != x_integer)      \
        {                                               \
            x_tree = nullptr;                           \
            TYPE(nil);                                  \
        })
#define REAL_TYPE(Name, Rep)                    \
BUILTIN(Name##_typecheck, (),                   \
        Rep rep = x_real;                       \
        if (!IsReal(xtype) || rep != x_real)    \
        {                                       \
            x_tree = nullptr;                   \
            TYPE(nil);                          \
        })
#define OTHER_TYPE(Name, Rep)                   \
BUILTIN(Name##_typecheck, (),                   \
        if (xtype != Name##_mtype)              \
        {                                       \
            x_tree = nullptr;                   \
            TYPE(nil);                          \
        })
#define TREE_TYPE(Name, Rep, Cast)                      \
BUILTIN(Name##_typecheck, (),                           \
        WANT_XTREE;                                     \
        if (xtype != Name##_mtype)                      \
        {                                               \
            Tree *value = x_tree;                       \
            x_tree = (Cast);                            \
            xtype = x_tree ? Name##_mtype : nil_mtype;  \
        })
#include "machine-types.tbl"



// ============================================================================
//
//   General evaluation opcodes
//
// ============================================================================

OPCODE(evaluate, (),
// ----------------------------------------------------------------------------
//   Evaluate x in current scope
// ----------------------------------------------------------------------------
       WANT_XTREE;
       x_tree = evaluate(scope, x_tree);
       CLASSIFY;
)


OPCODE(cast, (),
// ----------------------------------------------------------------------------
//   Cast the value x to type y
// ----------------------------------------------------------------------------
       WANT_XTREE;
       x_tree = typecheck(scope, y_tree, x_tree);
       CLASSIFY;
)


OPCODE(error, (CONSTANT),
// ----------------------------------------------------------------------------
//   Emit an error with the given arguments (not evaluated)
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       x_tree = new Prefix(error_type, x_tree);
       xtype = error_mtype;
)


OPCODE(error_exit, (CONSTANT),
// ----------------------------------------------------------------------------
//   Exit evaluation immediately with an error
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       x_tree = new Prefix(error_type, x_tree);
       xtype = error_mtype;
       return x_tree;
)


OPCODE(exit, (),
// ----------------------------------------------------------------------------
//   Terminate execution
// ----------------------------------------------------------------------------
       WANT_XTREE;
       return x_tree;
)


OPCODE(native, (CONSTANT_natural),
// ----------------------------------------------------------------------------
//   Call a native function
// ----------------------------------------------------------------------------
       Natural::value_t addr = Constant<Natural::value_t>(pc);
       Native::opcode_fn fn = (Native::opcode_fn) addr;
       fn(state);
       x = state.Pop();
       CLASSIFY;
)


OPCODE(xtoy, (),
// ----------------------------------------------------------------------------
//   Copy X to Y
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;
       y = x;
       READ_RUNVALUES;
)



OPCODE(swap, (),
// ----------------------------------------------------------------------------
//   Swap X and Y
// ----------------------------------------------------------------------------
       WANT_RUNVALUES;
       std::swap(x,y);
       READ_RUNVALUES;
)



OPCODE(check_statement, (),
// ----------------------------------------------------------------------------
//   If we have an error on top of stack, exit, otherwise check we have nil
// ----------------------------------------------------------------------------
       if (xtype == error_mtype)
           CHAIN(ret);
       if (xtype != nil_mtype)
       {
           Error error("Non-nil result from statement");
           state.Error(error);
           xtype = error_mtype;
           CHAIN(ret);
       }
)


OPCODE(branch, (JUMP),
// ----------------------------------------------------------------------------
//   Branch to the given target
// ----------------------------------------------------------------------------
       opcode_t offset = DATA;
       pc += offset;
)


OPCODE(nil, (),
// ----------------------------------------------------------------------------
//   Generate a nil value
// ----------------------------------------------------------------------------
       x_tree = nullptr;
       TYPE(nil);
)


OPCODE(true, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x_boolean = true;
       TYPE(boolean);
)


OPCODE(false, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x_boolean = false;
       TYPE(boolean);
)


OPCODE(constant, (CONSTANT),
// ----------------------------------------------------------------------------
//   Deposit a constant tree on the stack
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       TYPE(tree);
       CLASSIFY;
)


// ----------------------------------------------------------------------------
// Constants for the various representation types
// ----------------------------------------------------------------------------
#define TREE_TYPE(Name, Rep, Cast)
#define RUNTIME_TYPE(Name, Rep, BC)             \
OPCODE(constant_##Name, (CONSTANT_##Name),      \
       x_##BC = Constant<Rep>(pc);              \
       TYPE(Name);                              \
)
#include "machine-types.tbl"


OPCODE(make_variable, (),
// ----------------------------------------------------------------------------
//   Turn a tree into a variable tree
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree *type = x_tree;
       if (!IsVariableType(type))
       {
           type = new Prefix(xl_variable, type, type->Position());
           x_tree = type;
           TYPE(prefix);
       }
)


OPCODE(make_matching, (),
// ----------------------------------------------------------------------------
//   Turn something into a pattern matching type
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree *type = x_tree;
       if (!IsPatternMatchingType(type))
       {
           type = new Prefix(xl_matching, type, type->Position());
           x_tree = type;
           TYPE(prefix);
       }
)


OPCODE(get_scope, (),
// ----------------------------------------------------------------------------
//   Return current scope
// ----------------------------------------------------------------------------
       x_tree = state.EvaluationScope();
       TYPE(scope);
)


OPCODE(get_super, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       x_tree = state.EvaluationScope()->Enclosing();
       TYPE(scope);
)


OPCODE(get_self, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       x_tree = state.self;
       CLASSIFY;
)


OPCODE(set_scope, (),
// ----------------------------------------------------------------------------
//   Set the scope
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Scope *scope = x_tree->As<Scope>();
       if (!scope)
           record(opcode_error, "set_scope received non-scope %t", x_tree);
       state.scope = scope;
)


OPCODE(enter, (),
// ----------------------------------------------------------------------------
//   Enter a nested scope
// ----------------------------------------------------------------------------
       Context context(state.scope);
       state.scope = context.CreateScope();
       locals = state.Depth();
       REFRAME;
)


OPCODE(call_constant, (CONSTANT, ARGUMENTS),
// ----------------------------------------------------------------------------
//   Call a constant tree
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       CHAIN(call);
)


OPCODE(call, (ARGUMENTS),
// ----------------------------------------------------------------------------
//    Call X with the given arguments
// ----------------------------------------------------------------------------
       // Push PC and locals value
       state.Push(RunValue(pc, runvalue_pc));
       state.Push(RunValue(locals, runvalue_locals));
       state.Push(RunValue(bc, runvalue_bytecode));

       size_t base = state.Depth();
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           opcode_t index = DATA;
           state.Push(frame[index]);
       }
       pc = 0;
       bc = x_tree->GetInfo<Bytecode>();
       if (!bc)
       {
           record(opcode_error, "Calling %t which was not compiled", x_tree);
           return nullptr;
       }
       XL_ASSERT(bc->parameters.size() == nargs);
       locals = base;
       state.Allocate(bc->locals); // Add locals on top of arguments

       REFRAME;
       RETARGET;
)


OPCODE(ret, (),
// ----------------------------------------------------------------------------
//    Return to caller, returning the result as X in RunValue as is
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;

       state.Cut(locals);
       if (locals)
       {
           bc = (Bytecode *) state.Pop(runvalue_bytecode).as_natural;
           locals = state.Pop(runvalue_locals).as_natural;
           pc = state.Pop(runvalue_pc).as_natural;
       }
       else
       {
           return x.AsTree();
       }
       RETARGET;
)


OPCODE(assign, (),
// ----------------------------------------------------------------------------
//   Perform an assignment X := Y
// ----------------------------------------------------------------------------
       WANT_TREES;

       Rewrite_p rewrite = x_tree->As<XL::Rewrite>();
       if (rewrite)
       {
           rewrite->right = y_tree;
           TYPE(nil);
       }
       else
       {
           Error error("Cannot assign to non-variable $1", x_tree);
           state.Error(error);
           x_tree = error;
           TYPE(error);
       }
)


OPCODE(store, (LOCAL),
// ----------------------------------------------------------------------------
//   Save X to a local storage (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;
       opcode_t index = DATA;
       frame[index] = x;
)


OPCODE(load, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       x = frame[index];
       READ_XRUNVALUE;
)


OPCODE(loady, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value into y
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       y = frame[index];
       READ_YRUNVALUE;
)


OPCODE(init_value, (DEFINITION),
// ----------------------------------------------------------------------------
//   Initialize a named constant
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Rewrite_p rewrite = bc->Definition(DATA);
       rewrite->right = x_tree;
)


// ============================================================================
//
//    Checks - Branch to target in case of failure, leave value in X
//
// ============================================================================

OPCODE(check_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check a type at runtime
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree_p value = x_tree;
       Tree_p type = Constant(DATA);
       opcode_t branch = DATA;
       x_tree = typecheck(state.scope, type, value);
       if (!x_tree)
           pc += branch;
       CLASSIFY;
)


OPCODE(check_input_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an input argument
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_result_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an argument
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_init_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an initializer
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_typecast, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Evaluate a type cast, i.e. [X as Y]
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_guard, (JUMP),
// ----------------------------------------------------------------------------
//   Check if the guard condition is true, or nullify the stack
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       if (xtype != boolean_mtype || !x_boolean)
           pc += branch;
)


OPCODE(check_same, (JUMP),
// ----------------------------------------------------------------------------
//   Check if X and Y match, if not branch to taget
// ----------------------------------------------------------------------------
       WANT_TREES;
       opcode_t branch = DATA;
       if (!Tree::Equal(x_tree, y_tree))
           pc += branch;
)


OPCODE(check_natural, (CONSTANT_natural, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a natural constant
// ----------------------------------------------------------------------------
       uintptr_t ref = Constant<Natural::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != natural_mtype || x_natural != ref)
           pc += branch;
)


OPCODE(check_real, (CONSTANT_real, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a real constant
// ----------------------------------------------------------------------------
       double ref = Constant<Real::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != real_mtype || x_real != ref)
           pc += branch;
)


OPCODE(check_text, (CONSTANT_text, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a text constant
// ----------------------------------------------------------------------------
       text ref = Constant<Text::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != text_mtype || x_text != ref)
           pc += branch;
)


OPCODE(check_infix, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we have an infix, and if so, split it into two components
// ----------------------------------------------------------------------------
//   We have [infix], we will have either [right, left], or [nullptr]
       WANT_XTREE;

       Tree *ref = Constant(DATA);
       opcode_t offset = DATA;
       Infix *refinfix = ref->AsInfix();
       if (!refinfix)
       {
           record(opcode_error, "check_infix with non-infix reference %t", ref);
           return nullptr;
       }
       Infix *infix = x_tree->AsInfix();
       if (!infix || infix->name != refinfix->name)
           pc += offset;
       else
           xtype = infix_mtype;
)


OPCODE(check_borrow, (JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration
// ----------------------------------------------------------------------------
       opcode_t offset = DATA;
       Rewrite *rewrite = x_tree->As<Rewrite>();
       if (!rewrite)
           pc += offset;
       else
           xtype = definition_mtype;
)


OPCODE(check_typed_borrow, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration and check its type
// ----------------------------------------------------------------------------
       Tree_p type = Constant(DATA);
       opcode_t offset = DATA;
       Rewrite *rewrite = x_tree->As<Rewrite>();
       bool ok = false;
       if (rewrite)
       {
           xtype = definition_mtype;

           Infix *vartype = IsTypeAnnotation(rewrite->left);
           Tree_p have = vartype->right;
           if (Tree::Equal(type, have))
               ok = true;
       }
       if (!ok)
           pc += offset;
)

#undef OPCODE
#undef BUILTIN
