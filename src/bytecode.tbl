// ****************************************************************************
//  bytecode.tbl                                                    XL project
// ****************************************************************************
//
//   File Description:
//
//     Definition of the bytecodes used in bytecode.cpp
//
//     Put them in a separate file mostly for convenience:
//     This is not a regular header file to be included by multiple sources.
//
//
//
//
//
// ****************************************************************************
//   (C) 2021 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
// ****************************************************************************
//   This file is part of XL.
//
//   XL is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   XL is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with XL.  If not, see <https://www.gnu.org/licenses/>.
// ****************************************************************************



// ============================================================================
//
//    Opcodes exposed as builtins
//
// ============================================================================

// Builtins are the ones exposed through the [builtin "ABC"] construct
#ifndef BUILTIN
#define BUILTIN(Name, Parms, Body)      OPCODE(Name, Parms, Body)
#endif

// Type checks
#define NATURAL_TYPE(Name, Rep)                         \
    BUILTIN(Name##_cast, (LOCAL),                       \
            RunValue &x = OUTPUT_VALUE;                 \
            if (!x.CastNatural<Rep, Name##_mtype>())    \
                x = RunValue(nil_mtype); )              \
    BUILTIN(Name##_typecheck, (LOCAL, JUMP),            \
            RunValue &x = OUTPUT_VALUE;                 \
            opcode_t branch = DATA;                     \
            if (!x.CastNatural<Rep, Name##_mtype>())    \
                pc += branch; )

#define INTEGER_TYPE(Name, Rep)                         \
    BUILTIN(Name##_cast, (LOCAL),                       \
            RunValue &x = OUTPUT_VALUE;                 \
            if (!x.CastInteger<Rep, Name##_mtype>())    \
                x = RunValue(nil_mtype); )              \
    BUILTIN(Name##_typecheck, (LOCAL, JUMP),            \
            RunValue &x = OUTPUT_VALUE;                 \
            opcode_t branch = DATA;                     \
            if (!x.CastInteger<Rep, Name##_mtype>())    \
                pc += branch; )

#define REAL_TYPE(Name, Rep)                            \
    BUILTIN(Name##_cast, (LOCAL),                       \
            RunValue &x = OUTPUT_VALUE;                 \
            if (!x.CastReal<Rep, Name##_mtype>())       \
                x = RunValue(nil_mtype); )              \
    BUILTIN(Name##_typecheck, (LOCAL, JUMP),            \
            RunValue &x = OUTPUT_VALUE;                 \
            opcode_t branch = DATA;                     \
            if (!x.CastReal<Rep, Name##_mtype>())       \
                pc += branch; )                         \

#define OTHER_TYPE(Name, Rep)                   \
    BUILTIN(Name##_cast, (LOCAL),               \
            RunValue &x = OUTPUT_VALUE;         \
            if (x.type != Name##_mtype)         \
                x = RunValue(nil_mtype); )      \
    BUILTIN(Name##_typecheck, (LOCAL, JUMP),    \
            RunValue &x = OUTPUT_VALUE;         \
            opcode_t branch = DATA;             \
            if (x.type != Name##_mtype)         \
                pc += branch; )

#define TREE_TYPE(Name, Rep, Cast)                      \
    BUILTIN(Name##_cast, (),                            \
            RunValue &x = OUTPUT_VALUE;                 \
            if (x.type != Name##_mtype)                 \
            {                                           \
                Tree *value = x.AsTree();               \
                Rep *cast = (Cast);                     \
                x = cast                                \
                    ? RunValue(cast, Name##_mtype)      \
                    : RunValue(nil_mtype);              \
            })                                          \
    BUILTIN(Name##_typecheck, (LOCAL, JUMP),            \
            RunValue &x = OUTPUT_VALUE ;                \
            opcode_t branch = DATA;                     \
            if (x.type != Name##_mtype)                 \
            {                                           \
                Tree *value = x.AsTree();               \
                Rep *cast = (Cast);                     \
                if (cast)                               \
                    x = RunValue(cast, Name##_mtype);   \
                else                                    \
                    pc += branch;                       \
            })

#include "machine-types.tbl"


// Arithmetic opcodes
#define UNARY0(Op, TypeX, TypeR, RepXY, RepR, Body)     \
    BUILTIN(Op, (LOCAL, LOCAL),                         \
            RunValue &x = INPUT_VALUE;                  \
            XL_ASSERT(x.type == TypeX##_mtype);         \
            RepXY value = x.as_##TypeX;                 \
            RepR  result;                               \
            Body;                                       \
            RunValue &r = OUTPUT_VALUE;                 \
            r = RunValue(result, TypeR##_mtype); )
#define UNARY2(Op, TypeX, TypeR, RepXY, RepR, Body)     \
    UNARY0(Op##_##TypeX, TypeX, TypeR, RepXY, RepR, Body)
#define UNARY(Op, Type, Rep, Body)                      \
    UNARY2(Op, Type, Type, Rep, Rep, Body)

#define BINARY2(Op, TypeXY, TypeR, RepXY, RepR, Body)   \
    BUILTIN(Op##_##TypeXY, (LOCAL, LOCAL, LOCAL),       \
            RunValue &x = INPUT_VALUE;                  \
            RunValue &y = INPUT_VALUE;                  \
            XL_ASSERT(x.type == TypeXY##_mtype);        \
            XL_ASSERT(y.type == TypeXY##_mtype);        \
            RepXY left  = x.as_##TypeXY;                \
            RepXY right = y.as_##TypeXY;                \
            RepR  result;                               \
            Body;                                       \
            RunValue &r = OUTPUT_VALUE;                 \
            r = RunValue(result, TypeR##_mtype); )
#define BINARY(Op, Type, Rep, Body)             \
        BINARY2(Op, Type, Type, Rep, Rep, Body)
#define DIVIDE(Op, Type, Rep, Body)                     \
    BINARY(Op, Type, Rep,                               \
           if (!right)                                  \
               goto divide_by_zero;                     \
           Body)

#define ARITH(Name, Rep, BC)                                    \
    BINARY(add, Name, Rep, result = left + right)               \
    BINARY(sub, Name, Rep, result = left - right)               \
    BINARY(mul, Name, Rep, result = left * right)               \
    DIVIDE(div, Name, Rep, result = left / right)               \
    DIVIDE(mod, Name, Rep, mod_##BC(result, left, right))       \
    DIVIDE(rem, Name, Rep, rem_##BC(result, left, right))       \
    BINARY(pow, Name, Rep, pow_##BC(result, left, right))       \
    UNARY (neg, Name, Rep, result = -value)

#define SHIFTS(Name, Rep, BC)                               \
    BINARY(shl, Name, Rep, result = left << right)          \
    BINARY(shr, Name, Rep, result = left >> right)

#define LOGICAL(Name, Rep, BC)                              \
    BINARY(and, Name, Rep, result = left & right)           \
    BINARY(or,  Name, Rep, result = left | right)           \
    BINARY(xor, Name, Rep, result = left ^ right)           \
    UNARY (not, Name, Rep, result = not_##BC(value))

#define COMPARE(Name, Rep, BC)                                          \
    BINARY2(eq, Name, boolean, Rep, bool,       result = left == right) \
    BINARY2(ne, Name, boolean, Rep, bool,       result = left != right) \
    BINARY2(lt, Name, boolean, Rep, bool,       result = left <  right) \
    BINARY2(gt, Name, boolean, Rep, bool,       result = left  > right) \
    BINARY2(le, Name, boolean, Rep, bool,       result = left <= right) \
    BINARY2(ge, Name, boolean, Rep, bool,       result = left >= right)

#define NATURAL_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, natural)                 \
    SHIFTS(Name,  Rep, natural)                 \
    LOGICAL(Name, Rep, natural)                 \
    COMPARE(Name, Rep, natural)

#define INTEGER_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, integer)                 \
    SHIFTS(Name,  Rep, integer)                 \
    LOGICAL(Name, Rep, integer)                 \
    COMPARE(Name, Rep, integer)

#define REAL_TYPE(Name, Rep)                    \
    ARITH(Name,   Rep, real)                    \
    COMPARE(Name, Rep, real)

#include "machine-types.tbl"

LOGICAL(boolean, bool, boolean)
COMPARE(boolean, bool, boolean)

BINARY2(eq, text, boolean, text *, bool,       result = *left == *right)
BINARY2(ne, text, boolean, text *, bool,       result = *left != *right)
BINARY2(lt, text, boolean, text *, bool,       result = *left <  *right)
BINARY2(gt, text, boolean, text *, bool,       result = *left  > *right)
BINARY2(le, text, boolean, text *, bool,       result = *left <= *right)
BINARY2(ge, text, boolean, text *, bool,       result = *left >= *right)
BINARY2(concat, text, text, text *, text *,    result = new text(*left + *right))

UNARY0(tree_kind, tree, natural, Tree *, ulonglong, result = value->Kind())
UNARY0(prefix_left, prefix, tree, Prefix *, Tree *, result = value->left)
UNARY0(prefix_right, prefix, tree, Prefix *, Tree *, result = value->right)
UNARY0(postfix_left, postfix, tree, Postfix *, Tree *, result = value->left)
UNARY0(postfix_right, postfix, tree, Postfix *, Tree *, result = value->right)
UNARY0(infix_left, infix, tree, Infix *, Tree *, result = value->left)
UNARY0(infix_right, infix, tree, Infix *, Tree *, result = value->right)
UNARY0(infix_name, infix, text, Infix *, text *, result = new text(value->name))
UNARY0(block_child, block, tree, Block *, Tree *, result = value->child)
UNARY0(block_opening, block, text, Block *, text *,
       result = new text(value->opening))
UNARY0(block_closing, block, text, Block *, text *,
       result = new text(value->closing))



#undef UNARY
#undef UNARY0
#undef UNARY2
#undef BINARY
#undef BINARY2



// ============================================================================
//
//   General evaluation opcodes
//
// ============================================================================

OPCODE(evaluate, (LOCAL, LOCAL),
// ----------------------------------------------------------------------------
//   Evaluate x in current scope
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       Tree_p expr = x.AsTree();
       expr = evaluate(scope, expr);
       RunValue &r = OUTPUT_VALUE;
       r = RunValue::Classify(expr);
)


OPCODE(cast, (LOCAL, LOCAL, CONSTANT),
// ----------------------------------------------------------------------------
//   Cast the value in first register to the type in second register
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       Tree_p expr = x.AsTree();
       RunValue &type = cst[DATA];
       XL_ASSERT(IsTree(type.type));
       expr = typecheck(scope, type.as_tree, expr);
       RunValue &r = OUTPUT_VALUE;
       r = RunValue::Classify(expr);
)


OPCODE(error, (LOCAL, CONSTANT),
// ----------------------------------------------------------------------------
//   Emit an error with the given arguments (not evaluated)
// ----------------------------------------------------------------------------
       RunValue &error = INPUT_CONSTANT;
       XL_ASSERT(error.type == error_mtype);
       RunValue &r = INPUT_VALUE;
       r = error;
)


OPCODE(error_exit, (CONSTANT),
// ----------------------------------------------------------------------------
//   Exit evaluation immediately with an error
// ----------------------------------------------------------------------------
       RunValue &error = INPUT_CONSTANT;
       XL_ASSERT(error.type == error_mtype);
       CHAIN(ret, 1);
)


OPCODE(form_error, (LOCAL),
// ----------------------------------------------------------------------------
//   No form matches the given input
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       Tree_p form = x.AsTree();
       Error error("No form matches $1", form);
       x = RunValue((Tree *) error, error_mtype);
       CHAIN(ret, 1);
)


OPCODE(exit, (LOCAL),
// ----------------------------------------------------------------------------
//   Terminate execution
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       return x.AsTree();
)


OPCODE(native, (NATIVE, ARGUMENTS, LOCAL),
// ----------------------------------------------------------------------------
//   Call a native function
// ----------------------------------------------------------------------------
       // Find the associated native function
       Native::opcode_fn fn = natives[DATA];

       // Read arguments
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           state.Push(INPUT_VALUE);
       }

       fn(state);
       RunValue &r = OUTPUT_VALUE;
       r = state.Pop().Classify();
       REFRAME;
)


OPCODE(check_statement, (LOCAL),
// ----------------------------------------------------------------------------
//   If we have an error on top of stack, exit, otherwise check we have nil
// ----------------------------------------------------------------------------
       RunValue &r = INPUT_VALUE;
       if (r.type == error_mtype)
           CHAIN(ret, 1);
       if (r.type != nil_mtype)
       {
           Error error("Non-nil result from statement");
           state.Error(error);
           r = RunValue(state.Error(), error_mtype);
           CHAIN(ret, 1);
       }
)


OPCODE(branch, (JUMP),
// ----------------------------------------------------------------------------
//   Branch to the given target
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       pc += branch;
)


OPCODE(get_scope, (LOCAL),
// ----------------------------------------------------------------------------
//   Return current scope
// ----------------------------------------------------------------------------
       Scope *scope = state.EvaluationScope();
       RunValue &r = OUTPUT_VALUE;
       r = RunValue(scope, scope_mtype);
)


OPCODE(get_super, (LOCAL),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       Scope *scope = state.EvaluationScope()->Enclosing();
       RunValue &r = OUTPUT_VALUE;
       r = RunValue(scope, scope_mtype);
)


OPCODE(get_self, (LOCAL),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       RunValue &r = OUTPUT_VALUE;
       r = RunValue::Classify(state.self);
)


OPCODE(set_scope, (LOCAL),
// ----------------------------------------------------------------------------
//   Set the scope
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       XL_ASSERT(x.type == scope_mtype);
       Scope *scope = x.as_scope;
       state.scope = scope;
)


OPCODE(call, (CONSTANT, ARGUMENTS, LOCAL),
// ----------------------------------------------------------------------------
//    Call X with the given arguments
// ----------------------------------------------------------------------------
       RunValue &callee = INPUT_VALUE;
       XL_ASSERT(IsTree(callee.type));

       // Push PC and locals value
       state.Push(RunValue(ret_pc, runvalue_pc));
       state.Push(RunValue(locals, runvalue_locals));
       state.Push(RunValue(bc, runvalue_bytecode));

       size_t base = state.Depth();
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           state.Push(INPUT_VALUE);
       }
       ret_pc = pc;
       bc = (Bytecode *) callee.as_tree->code;
       if (!bc)
       {
           record(opcode_error, "Calling %t which was not compiled",
                  callee.as_tree);
           return nullptr;
       }
       XL_ASSERT(bc->parameters.size() == nargs);
       locals = base;
       if (bc->locals)
           state.Allocate(bc->locals); // Add locals on top of arguments

       REFRAME;
       RETARGET(&bc->code[0]);
)


OPCODE(ret, (LOCAL),
// ----------------------------------------------------------------------------
//    Return to caller, the returned value is in x
// ----------------------------------------------------------------------------
       RunValue result = INPUT_VALUE;
       state.Cut(locals);
       if (locals)
       {
           bc = (Bytecode *) state.Pop(runvalue_bytecode).as_natural;
           locals = state.Pop(runvalue_locals).as_natural;
           RETARGET(ret_pc);
           ret_pc = (opcode_t *) state.Pop(runvalue_pc).as_natural;
           REFRAME;
           RunValue &target = INPUT_VALUE;
           target = result;
       }
       else
       {
           return result.AsTree();
       }
)


OPCODE(copy, (LOCAL, LOCAL),
// ----------------------------------------------------------------------------
//   Copy a value from source to target
// ----------------------------------------------------------------------------
       RunValue &source = INPUT_VALUE;
       RunValue &target = OUTPUT_VALUE;
       target = source;
)


OPCODE(init_value, (LOCAL, DEFINITION),
// ----------------------------------------------------------------------------
//   Initialize a named constant
// ----------------------------------------------------------------------------
       RunValue &source = INPUT_VALUE;
       RunValue &target = OUTPUT_VALUE;
       target = source;
)



// ============================================================================
//
//    Checks - Branch to target in case of failure, leave value in X
//
// ============================================================================

OPCODE(check_type, (CONSTANT, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check a type at runtime
// ----------------------------------------------------------------------------
       RunValue &type = INPUT_CONSTANT;
       RunValue &value = INPUT_VALUE;
       opcode_t branch = DATA;
       XL_ASSERT(IsTree(type.type));
       Tree_p cast = typecheck(state.scope, type.as_tree, value.as_tree);
       if (cast)
           value = RunValue::Classify(cast);
       else
           pc += branch;
)


OPCODE(check_input_type, (CONSTANT, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an input argument
// ----------------------------------------------------------------------------
       CHAIN(check_type, 0);
)


OPCODE(check_init_type, (CONSTANT, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an initializer
// ----------------------------------------------------------------------------
       CHAIN(check_type, 0);
)


OPCODE(check_typecast, (CONSTANT, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Evaluate a type cast, i.e. [X as Y]
// ----------------------------------------------------------------------------
       CHAIN(check_type, 0);
)


OPCODE(check_result_type, (CONSTANT, LOCAL),
// ----------------------------------------------------------------------------
//   Check the type of an argument, or return a type error
// ----------------------------------------------------------------------------
       RunValue &type = INPUT_CONSTANT;
       RunValue &value = INPUT_VALUE;
       XL_ASSERT(IsTree(type.type));
       Tree_p cast = typecheck(state.scope, type.as_tree, value.as_tree);
       if (cast)
       {
           value = RunValue::Classify(cast);
       }
       else
       {
           Error error("Returned value $1 does not match type $2",
                       value.as_tree, type.as_tree);
           value = RunValue((Tree *) error, error_mtype);
           CHAIN(ret, 1);
       }
)


OPCODE(check_guard, (LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check if the guard condition is true, or nullify the stack
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_VALUE;
       opcode_t branch = DATA;
       if (value.type != boolean_mtype || !value.as_boolean)
           pc += branch;
)


OPCODE(check_same, (LOCAL, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check if X and Y match, if not branch to taget
// ----------------------------------------------------------------------------
       RunValue &x = INPUT_VALUE;
       RunValue &y = INPUT_VALUE;
       opcode_t branch = DATA;
       if (!Tree::Equal(x.AsTree(), y.AsTree()))
           pc += branch;
)


OPCODE(check_natural, (LOCAL, CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a natural constant
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_VALUE;
       RunValue &ref = INPUT_CONSTANT;
       XL_ASSERT(IsNatural(ref.type));
       opcode_t branch = DATA;
       if (!IsNatural(value.type) || value.AsNatural() != ref.AsNatural())
           pc += branch;
)


OPCODE(check_real, (LOCAL, CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a real constant
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_VALUE;
       RunValue &ref = INPUT_CONSTANT;
       XL_ASSERT(IsReal(ref.type));
       opcode_t branch = DATA;
       if (!IsReal(value.type) || value.AsReal() != ref.AsReal())
           pc += branch;
)


OPCODE(check_text, (LOCAL, CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a text constant
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_VALUE;
       RunValue &ref = INPUT_CONSTANT;
       XL_ASSERT(IsText(ref.type));
       opcode_t branch = DATA;
       if (!IsText(value.type) || value.AsText() != ref.AsText())
           pc += branch;
)


OPCODE(check_infix, (LOCAL, CONSTANT, LOCAL, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check if we have an infix, and if so, split it into two components
// ----------------------------------------------------------------------------
//   We have [infix], we either
//   - jump to the target if no match,
//   - split into left and right that we store in the to locals
       RunValue &test = INPUT_VALUE;
       RunValue &ref = INPUT_CONSTANT;
       RunValue &left = OUTPUT_VALUE;
       RunValue &right = OUTPUT_VALUE;
       opcode_t branch = DATA;
       XL_ASSERT(ref.type == infix_mtype);
       Infix *refinfix = ref.as_infix;
       Infix *infix = test.AsTree()->AsInfix();
       if (!infix || infix->name != refinfix->name)
       {
           pc += branch;
       }
       else
       {
           if (test.type != infix_mtype)
               test = RunValue(infix, infix_mtype);
           XL_ASSERT(test.as_infix == infix);
           left  = RunValue::Classify(infix->left);
           right = RunValue::Classify(infix->right);
       }
)


OPCODE(check_borrow, (LOCAL, JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_VALUE;
       opcode_t branch = DATA;
       if (value.type != definition_mtype)
           pc += branch;
)


OPCODE(check_typed_borrow, (LOCAL, CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration and check its type
// ----------------------------------------------------------------------------
       RunValue &value = INPUT_CONSTANT;
       RunValue &type = INPUT_CONSTANT;
       XL_ASSERT(IsTree(type.type));
       opcode_t branch = DATA;
       bool ok = false;
       if (value.type == definition_mtype)
       {
           if (Infix *vartype = IsTypeAnnotation(value.as_definition->left))
           {
               Tree_p have = vartype->right;
               ok = Tree::Equal(type.as_tree, have);
           }
       }
       if (!ok)
           pc += branch;
)

#undef OPCODE
#undef BUILTIN
