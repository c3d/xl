// ****************************************************************************
//  bytecode.tbl                                                    XL project
// ****************************************************************************
//
//   File Description:
//
//     Definition of the bytecodes used in bytecode.cpp
//
//     Put them in a separate file mostly for convenience:
//     This is not a regular header file to be included by multiple sources.
//
//
//
//
//
// ****************************************************************************
//   (C) 2021 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
// ****************************************************************************
//   This file is part of XL.
//
//   XL is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   XL is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with XL.  If not, see <https://www.gnu.org/licenses/>.
// ****************************************************************************



// ============================================================================
//
//    Opcodes exposed as builtins
//
// ============================================================================

// Builtins are the ones exposed through the [builtin "ABC"] construct
#ifndef BUILTIN
#define BUILTIN(Name, Parms, Body)      OPCODE(Name, Parms, Body)
#endif

// Type checks
#define NATURAL_TYPE(Name, Rep)                          \
    BUILTIN(Name##_cast, (),                             \
            if (!x.CastNatural<Rep, Name##_mtype>())     \
                CHAIN(nil); )                            \
    BUILTIN(Name##_typecheck, (JUMP),                    \
            opcode_t branch = DATA;                      \
            if (!x.CastNatural<Rep, Name##_mtype>())     \
                pc += branch; )

#define INTEGER_TYPE(Name, Rep)                          \
    BUILTIN(Name##_cast, (),                             \
            if (!x.CastInteger<Rep, Name##_mtype>())     \
                CHAIN(nil); )                            \
    BUILTIN(Name##_typecheck, (JUMP),                    \
            opcode_t branch = DATA;                      \
            if (!x.CastInteger<Rep, Name##_mtype>())     \
                pc += branch; )

#define REAL_TYPE(Name, Rep)                             \
    BUILTIN(Name##_cast, (),                             \
            if (!x.CastReal<Rep, Name##_mtype>())        \
                CHAIN(nil); )                            \
    BUILTIN(Name##_typecheck, (JUMP),                    \
            opcode_t branch = DATA;                      \
            if (!x.CastReal<Rep, Name##_mtype>())        \
                pc += branch; )

#define OTHER_TYPE(Name, Rep)                   \
    BUILTIN(Name##_cast, (),                    \
            if (x.type != Name##_mtype)         \
                CHAIN(nil); )                   \
    BUILTIN(Name##_typecheck, (JUMP),           \
            opcode_t branch = DATA;             \
            if (x.type != Name##_mtype)         \
                pc += branch; )

#define TREE_TYPE(Name, Rep, Cast)                      \
    BUILTIN(Name##_cast, (),                            \
            if (x.type != Name##_mtype)                 \
            {                                           \
                Tree *value = x.AsTree();               \
                Rep *cast = (Cast);                     \
                if (!cast)                              \
                    CHAIN(nil);                         \
                x = RunValue(cast, Name##_mtype);       \
            })                                          \
    BUILTIN(Name##_typecheck, (JUMP),                   \
            opcode_t branch = DATA;                     \
            if (x.type != Name##_mtype)                 \
            {                                           \
                Tree *value = x.AsTree();               \
                Rep *cast = (Cast);                     \
                if (cast)                               \
                    x = RunValue(cast, Name##_mtype);   \
                else                                    \
                    pc += branch;                       \
            })

#include "machine-types.tbl"


// Arithmetic opcodes
#define UNARY2(Op, TypeX, TypeR, RepXY, RepR, Body)     \
    BUILTIN(Op##_##TypeX, (),                           \
            XL_ASSERT(x.type == TypeX##_mtype);         \
            RepXY value = x.as_##TypeX;                 \
            RepR  result;                               \
            Body;                                       \
            x.as_##TypeR = result;                      \
            if (TypeX##_mtype != TypeR##_mtype)         \
                x.type = TypeR##_mtype; )
#define UNARY(Op, Type, Rep, Body)                      \
    UNARY2(Op, Type, Type, Rep, Rep, Body)

#define BINARY2(Op, TypeXY, TypeR, RepXY, RepR, Body)           \
    BUILTIN(Op##_##TypeXY, (LOCAL),                             \
            RunValue &y = frame[DATA];                          \
            XL_ASSERT(x.type == TypeXY##_mtype);                \
            XL_ASSERT(y.type == TypeXY##_mtype);                \
            RepXY left  = y.as_##TypeXY;                        \
            RepXY right = x.as_##TypeXY;                        \
            RepR  result;                                       \
            Body;                                               \
            x.as_##TypeR = result;                              \
            if (TypeR##_mtype != TypeXY##_mtype)                \
                x.type = TypeR##_mtype; )                       \
    BUILTIN(Op##_constant_##TypeXY, (CONSTANT),                 \
            RunValue &y = cst[DATA];                            \
            XL_ASSERT(x.type == TypeXY##_mtype);                \
            XL_ASSERT(y.type == TypeXY##_mtype);                \
            RepXY left  = x.as_##TypeXY;                        \
            RepXY right = y.as_##TypeXY;                        \
            RepR  result;                                       \
            Body;                                               \
            x.as_##TypeR = result;                              \
            if (TypeXY##_mtype != TypeR##_mtype)                \
                x.type = TypeR##_mtype; )

#define BINARY(Op, Type, Rep, Body)                     \
        BINARY2(Op, Type, Type, Rep, Rep, Body)
#define DIVIDE(Op, Type, Rep, Body)                     \
    BINARY(Op, Type, Rep,                               \
           if (!right)                                  \
               goto divide_by_zero;                     \
           Body)

#define ARITH(Name, Rep, BC)                                    \
    BINARY(add, Name, Rep, result = left + right)               \
    BINARY(sub, Name, Rep, result = left - right)               \
    BINARY(mul, Name, Rep, result = left * right)               \
    DIVIDE(div, Name, Rep, result = left / right)               \
    DIVIDE(mod, Name, Rep, mod_##BC(result, left, right))       \
    DIVIDE(rem, Name, Rep, rem_##BC(result, left, right))       \
    BINARY(pow, Name, Rep, pow_##BC(result, left, right))       \
    UNARY (neg, Name, Rep, result = -value)

#define SHIFTS(Name, Rep, BC)                               \
    BINARY(shl, Name, Rep, result = left << right)          \
    BINARY(shr, Name, Rep, result = left >> right)

#define LOGICAL(Name, Rep, BC)                              \
    BINARY(and, Name, Rep, result = left & right)           \
    BINARY(or,  Name, Rep, result = left | right)           \
    BINARY(xor, Name, Rep, result = left ^ right)           \
    UNARY (not, Name, Rep, result = not_##BC(value))

#define COMPARE(Name, Rep, BC)                                          \
    BINARY2(eq, Name, boolean, Rep, bool,       result = left == right) \
    BINARY2(ne, Name, boolean, Rep, bool,       result = left != right) \
    BINARY2(lt, Name, boolean, Rep, bool,       result = left <  right) \
    BINARY2(gt, Name, boolean, Rep, bool,       result = left  > right) \
    BINARY2(le, Name, boolean, Rep, bool,       result = left <= right) \
    BINARY2(ge, Name, boolean, Rep, bool,       result = left >= right)

#define NATURAL_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, natural)                 \
    SHIFTS(Name,  Rep, natural)                 \
    LOGICAL(Name, Rep, natural)                 \
    COMPARE(Name, Rep, natural)

#define INTEGER_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, integer)                 \
    SHIFTS(Name,  Rep, integer)                 \
    LOGICAL(Name, Rep, integer)                 \
    COMPARE(Name, Rep, integer)

#define REAL_TYPE(Name, Rep)                    \
    ARITH(Name,   Rep, real)                    \
    COMPARE(Name, Rep, real)

#include "machine-types.tbl"

LOGICAL(boolean, bool, boolean)
COMPARE(boolean, bool, boolean)

BINARY2(eq, text, boolean, text *, bool,       result = *left == *right)
BINARY2(ne, text, boolean, text *, bool,       result = *left != *right)
BINARY2(lt, text, boolean, text *, bool,       result = *left <  *right)
BINARY2(gt, text, boolean, text *, bool,       result = *left  > *right)
BINARY2(le, text, boolean, text *, bool,       result = *left <= *right)
BINARY2(ge, text, boolean, text *, bool,       result = *left >= *right)
BINARY2(concat, text, text, text *, text *,    result = new text(*left + *right))

#undef UNARY
#undef UNARY2
#undef BINARY
#undef BINARY2



// ============================================================================
//
//   General evaluation opcodes
//
// ============================================================================

OPCODE(evaluate, (),
// ----------------------------------------------------------------------------
//   Evaluate x in current scope
// ----------------------------------------------------------------------------
       Tree_p expr = x.AsTree();
       expr = evaluate(scope, expr);
       x = RunValue::Classify(expr);
)


OPCODE(cast, (CONSTANT),
// ----------------------------------------------------------------------------
//   Cast the value in first register to the type in second register
// ----------------------------------------------------------------------------
       Tree_p expr = x.AsTree();
       RunValue &type = cst[DATA];
       XL_ASSERT(IsTree(type.type));
       expr = typecheck(scope, type.as_tree, expr);
       x = RunValue::Classify(expr);
)


OPCODE(error, (CONSTANT),
// ----------------------------------------------------------------------------
//   Emit an error with the given arguments (not evaluated)
// ----------------------------------------------------------------------------
       RunValue &error = cst[DATA];
       XL_ASSERT(error.type == error_mtype);
       x = error;
)


OPCODE(error_exit, (CONSTANT),
// ----------------------------------------------------------------------------
//   Exit evaluation immediately with an error
// ----------------------------------------------------------------------------
       RunValue &error = cst[DATA];
       XL_ASSERT(error.type == error_mtype);
       return error.as_error;
)


OPCODE(form_error, (),
// ----------------------------------------------------------------------------
//   No form matches the given input
// ----------------------------------------------------------------------------
       Tree_p form = x.AsTree();
       Error error("No form matches $1", form);
       x = RunValue((Tree *) error, error_mtype);
       CHAIN(ret); )


OPCODE(exit, (),
// ----------------------------------------------------------------------------
//   Terminate execution
// ----------------------------------------------------------------------------
       return x.AsTree();
)


OPCODE(native, (NATIVE, ARGUMENTS),
// ----------------------------------------------------------------------------
//   Call a native function
// ----------------------------------------------------------------------------
       // Find the associated native function
       Native::opcode_fn fn = natives[DATA];

       // Read arguments
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           state.Push(frame[DATA]);
       }

       fn(state);
       x = state.Pop().Classify();
       REFRAME;
)


OPCODE(check_statement, (),
// ----------------------------------------------------------------------------
//   If we have an error on top of stack, exit, otherwise check we have nil
// ----------------------------------------------------------------------------
       if (x.type == error_mtype)
           CHAIN(ret);
       if (x.type != nil_mtype)
       {
           Error error("Non-nil result from statement");
           state.Error(error);
           x = RunValue(state.Error(), error_mtype);
           CHAIN(ret);
       }
)


OPCODE(branch, (JUMP),
// ----------------------------------------------------------------------------
//   Branch to the given target
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       pc += branch;
)


OPCODE(nil, (),
// ----------------------------------------------------------------------------
//   Generate a nil value
// ----------------------------------------------------------------------------
       x = RunValue(nil_mtype);
)


OPCODE(true, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x = RunValue(true, boolean_mtype);
)


OPCODE(false, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x = RunValue(false, boolean_mtype);
)


OPCODE(constant, (CONSTANT),
// ----------------------------------------------------------------------------
//   Deposit a constant on the stack
// ----------------------------------------------------------------------------
       x = cst[DATA];
)


OPCODE(rewrite, (DEFINITION),
// ----------------------------------------------------------------------------
//   Deposit a rewrite on the stack
// ----------------------------------------------------------------------------
       x = cst[DATA];
       XL_ASSERT(x.type == definition_mtype);
)


OPCODE(make_variable, (),
// ----------------------------------------------------------------------------
//   Turn a tree into a variable tree
// ----------------------------------------------------------------------------
       Tree_p type = x.AsTree();
       if (!IsVariableType(type))
       {
           type = new Prefix(xl_variable, type, type->Position());
           x = RunValue(type, prefix_mtype);
       }
)


OPCODE(make_matching, (),
// ----------------------------------------------------------------------------
//   Turn something into a pattern matching type
// ----------------------------------------------------------------------------
       Tree_p type = x.AsTree();
       if (!IsPatternMatchingType(type))
       {
           type = new Prefix(xl_matching, type, type->Position());
           x = RunValue(type, prefix_mtype);
       }
)


OPCODE(get_scope, (),
// ----------------------------------------------------------------------------
//   Return current scope
// ----------------------------------------------------------------------------
       Scope *scope = state.EvaluationScope();
       x = RunValue(scope, scope_mtype);
)


OPCODE(get_super, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       Scope *scope = state.EvaluationScope()->Enclosing();
       x = RunValue(scope, scope_mtype);
)


OPCODE(get_self, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       x = RunValue::Classify(state.self);
)


OPCODE(set_scope, (),
// ----------------------------------------------------------------------------
//   Set the scope
// ----------------------------------------------------------------------------
       XL_ASSERT(x.type == scope_mtype);
       Scope *scope = x.as_scope;
       state.scope = scope;
)


OPCODE(enter, (),
// ----------------------------------------------------------------------------
//   Enter a nested scope
// ----------------------------------------------------------------------------
       Context context(state.scope);
       state.scope = context.CreateScope();
       locals = state.Depth();
       REFRAME;
)


OPCODE(call_constant, (CONSTANT, ARGUMENTS),
// ----------------------------------------------------------------------------
//   Call a constant tree
// ----------------------------------------------------------------------------
       x = cst[DATA];
       XL_ASSERT(IsTree(x.type));
       CHAIN(call);
)


OPCODE(call, (ARGUMENTS),
// ----------------------------------------------------------------------------
//    Call X with the given arguments
// ----------------------------------------------------------------------------
       XL_ASSERT(IsTree(x.type));

       // Push PC and locals value
       state.Push(RunValue(ret_pc, runvalue_pc));
       state.Push(RunValue(locals, runvalue_locals));
       state.Push(RunValue(bc, runvalue_bytecode));

       size_t base = state.Depth();
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           opcode_t index = DATA;
           state.Push(IsConstantIndex(index)
                      ? cst[ConstantIndex(index)]
                      : frame[index]);
       }
       ret_pc = pc;
       bc = x.as_tree->GetInfo<Bytecode>();
       if (!bc)
       {
           record(opcode_error, "Calling %t which was not compiled", x.as_tree);
           return nullptr;
       }
       XL_ASSERT(bc->parameters.size() == nargs);
       locals = base;
       if (bc->locals)
           state.Allocate(bc->locals); // Add locals on top of arguments

       REFRAME;
       RETARGET(&bc->code[0]);
)


OPCODE(ret, (),
// ----------------------------------------------------------------------------
//    Return to caller, the returned value is in x
// ----------------------------------------------------------------------------
       state.Cut(locals);
       if (locals)
       {
           bc = (Bytecode *) state.Pop(runvalue_bytecode).as_natural;
           locals = state.Pop(runvalue_locals).as_natural;
           RETARGET(ret_pc);
           ret_pc = (opcode_t *) state.Pop(runvalue_pc).as_natural;
           REFRAME;
       }
       else
       {
           return x.AsTree();
       }
)


OPCODE(assign, (LOCAL),
// ----------------------------------------------------------------------------
//   Assign x to a definition stored in a local
// ----------------------------------------------------------------------------
       RunValue &target = frame[DATA];
       if (target.type != definition_mtype)
       {
           Error error("Cannot assign to non-variable $1", target.AsTree());
           state.Error(error);
           x = RunValue(state.Error(), error_mtype);
           CHAIN(ret);
       }

       Rewrite_p rewrite = x.as_definition;
       XL_ASSERT(rewrite && "Cannot assign to null definition");
       rewrite->right = x.AsTree();
)


OPCODE(store, (LOCAL),
// ----------------------------------------------------------------------------
//   Save X to a local storage (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       frame[index] = x;
)


OPCODE(load, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       x = frame[index];
)


OPCODE(init_value, (DEFINITION),
// ----------------------------------------------------------------------------
//   Initialize a named constant
// ----------------------------------------------------------------------------
       RunValue &rewrite = cst[DATA];
       XL_ASSERT(rewrite.type == definition_mtype);
       rewrite.as_definition->right = x.AsTree();
)



// ============================================================================
//
//    Checks - Branch to target in case of failure, leave value in X
//
// ============================================================================

OPCODE(check_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check a type at runtime
// ----------------------------------------------------------------------------
       Tree_p value = x.AsTree();
       RunValue &type = cst[DATA];
       opcode_t branch = DATA;
       XL_ASSERT(IsTree(type.type));
       Tree_p cast = typecheck(state.scope, type.as_tree, value);
       if (cast)
           x = RunValue::Classify(cast);
       else
           pc += branch;
)


OPCODE(check_input_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an input argument
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_result_type, (CONSTANT),
// ----------------------------------------------------------------------------
//   Check the type of an argument, or return a type error
// ----------------------------------------------------------------------------
       Tree_p value = x.AsTree();
       RunValue &type = cst[DATA];
       XL_ASSERT(IsTree(type.type));
       Tree_p cast = typecheck(state.scope, type.as_tree, value);
       if (cast)
       {
           x = RunValue::Classify(cast);
       }
       else
       {
           Error error("Returned value $1 does not match type $2",
                       value, type.as_tree);
           x = RunValue((Tree *) error, error_mtype);
           CHAIN(ret);
       }
)


OPCODE(check_init_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an initializer
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_typecast, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Evaluate a type cast, i.e. [X as Y]
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_guard, (JUMP),
// ----------------------------------------------------------------------------
//   Check if the guard condition is true, or nullify the stack
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       if (x.type != boolean_mtype || !x.as_boolean)
           pc += branch;
)


OPCODE(check_same, (LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check if X and Y match, if not branch to taget
// ----------------------------------------------------------------------------
       RunValue &y = frame[DATA];
       opcode_t branch = DATA;
       if (!Tree::Equal(x.AsTree(), y.AsTree()))
           pc += branch;
)


OPCODE(check_natural, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a natural constant
// ----------------------------------------------------------------------------
       RunValue &ref = cst[DATA];
       XL_ASSERT(IsNatural(ref.type));
       opcode_t branch = DATA;
       if (!IsNatural(x.type) || x.AsNatural() != ref.AsNatural())
           pc += branch;
)


OPCODE(check_real, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a real constant
// ----------------------------------------------------------------------------
       RunValue &ref = cst[DATA];
       XL_ASSERT(IsReal(ref.type));
       opcode_t branch = DATA;
       if (!IsReal(x.type) || x.AsReal() != ref.AsReal())
           pc += branch;
)


OPCODE(check_text, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a text constant
// ----------------------------------------------------------------------------
       RunValue &ref = cst[DATA];
       XL_ASSERT(IsText(ref.type));
       opcode_t branch = DATA;
       if (!IsText(x.type) || x.AsText() != ref.AsText())
           pc += branch;
)


OPCODE(check_infix, (CONSTANT, LOCAL, LOCAL, JUMP),
// ----------------------------------------------------------------------------
//   Check if we have an infix, and if so, split it into two components
// ----------------------------------------------------------------------------
//   We have [infix], we either
//   - jump to the target if no match,
//   - split into left and right that we store in the to locals
       RunValue &ref = cst[DATA];
       RunValue &left = frame[DATA];
       RunValue &right = frame[DATA];
       opcode_t branch = DATA;
       XL_ASSERT(ref.type == infix_mtype);
       Infix *refinfix = ref.as_infix;
       Infix *infix = x.AsTree()->AsInfix();
       if (!infix || infix->name != refinfix->name)
       {
           pc += branch;
       }
       else
       {
           if (x.type != infix_mtype)
               x = RunValue(infix, infix_mtype);
           XL_ASSERT(x.as_infix == infix);
           left  = RunValue::Classify(infix->left);
           right = RunValue::Classify(infix->right);
       }
)


OPCODE(check_borrow, (JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       if (x.type != definition_mtype)
           pc += branch;
)


OPCODE(check_typed_borrow, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration and check its type
// ----------------------------------------------------------------------------
       RunValue &type = cst[DATA];
       XL_ASSERT(IsTree(type.type));
       opcode_t branch = DATA;
       bool ok = false;
       if (x.type == definition_mtype)
       {
           if (Infix *vartype = IsTypeAnnotation(x.as_definition->left))
           {
               Tree_p have = vartype->right;
               ok = Tree::Equal(type.as_tree, have);
           }
       }
       if (!ok)
           pc += branch;
)

#undef OPCODE
#undef BUILTIN
