// ****************************************************************************
//  bytecode.tbl                                                    XL project
// ****************************************************************************
//
//   File Description:
//
//     Definition of the bytecodes used in bytecode.cpp
//
//     Put them in a separate file mostly for convenience:
//     This is not a regular header file to be included by multiple sources.
//
//
//
//
//
// ****************************************************************************
//   (C) 2021 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
// ****************************************************************************
//   This file is part of XL.
//
//   XL is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   XL is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with XL.  If not, see <https://www.gnu.org/licenses/>.
// ****************************************************************************



// ============================================================================
//
//    Opcodes exposed as builtins
//
// ============================================================================

// Builtins are the ones exposed through the [builtin "ABC"] construct
#ifndef BUILTIN
#define BUILTIN(Name, Parms, Body)      OPCODE(Name, Parms, Body)
#endif

// Type checks
#define NATURAL_TYPE(Name, Rep)                         \
    BUILTIN(Name##_cast, (),                            \
            Rep rep = x_natural;                        \
            if (!IsNatural(xtype) || rep != x_natural)  \
            {                                           \
                x_tree = nullptr;                       \
                TYPE(nil);                              \
            })                                          \
    BUILTIN(Name##_typecheck, (JUMP),                   \
            Rep rep = x_natural;                        \
            opcode_t offset = DATA;                     \
            if (!IsNatural(xtype) || rep != x_natural)  \
                pc += offset;)
#define INTEGER_TYPE(Name, Rep)                         \
    BUILTIN(Name##_cast, (),                            \
            Rep rep = x_integer;                        \
            if (!IsInteger(xtype) || rep != x_integer)  \
            {                                           \
                x_tree = nullptr;                       \
                TYPE(nil);                              \
            })                                          \
    BUILTIN(Name##_typecheck, (JUMP),                   \
            Rep rep = x_integer;                        \
            opcode_t offset = DATA;                     \
            if (!IsInteger(xtype) || rep != x_integer)  \
                pc += offset;)
#define REAL_TYPE(Name, Rep)                    \
    BUILTIN(Name##_cast, (),                    \
            Rep rep = x_real;                   \
            if (!IsReal(xtype) || rep != x_real)        \
            {                                           \
                x_tree = nullptr;                       \
                TYPE(nil);                              \
            })                                          \
    BUILTIN(Name##_typecheck, (JUMP),                   \
            Rep rep = x_real;                           \
            opcode_t offset = DATA;                     \
            if (!IsReal(xtype) || rep != x_real)        \
                pc += offset;)
#define OTHER_TYPE(Name, Rep)                   \
    BUILTIN(Name##_cast, (),                    \
            if (xtype != Name##_mtype)          \
            {                                   \
                x_tree = nullptr;               \
                TYPE(nil);                      \
            })                                  \
    BUILTIN(Name##_typecheck, (JUMP),           \
            opcode_t offset = DATA;             \
            if (xtype != Name##_mtype)          \
                pc += offset;)
#define TREE_TYPE(Name, Rep, Cast)                      \
    BUILTIN(Name##_cast, (),                            \
            WANT_XTREE;                                 \
            if (xtype != Name##_mtype)                  \
            {                                           \
                Tree *value = x_tree;                   \
                x_tree = (Cast);                        \
                xtype = x_tree ? Name##_mtype : nil_mtype;      \
            })                                                  \
    BUILTIN(Name##_typecheck, (JUMP),                           \
            WANT_XTREE;                                         \
            opcode_t offset = DATA;                             \
            if (xtype != Name##_mtype)                          \
            {                                                   \
                Tree *value = x_tree;                           \
                x_tree = (Cast);                                \
                xtype = x_tree ? Name##_mtype : nil_mtype;      \
                if (!x_tree)                                    \
                    pc += offset;                               \
            })
#include "machine-types.tbl"


// Arithmetic
#define DIVIDER(Name, BC, Body)                 \
    BUILTIN(Name, (),                           \
            if (!y_##BC) goto divide_by_zero;   \
            Body)

#define mod_natural(Rep, x, y)          x = x % y
#define rem_natural(Rep, x, y)          x = x % y
#define pow_natural(Rep, x, y)                  \
{                                               \
    Rep result = 1;                             \
    while (y > 0)                               \
    {                                           \
        if (y & 1)                              \
            result *= x;                        \
        x *= x;                                 \
        y >>= 1;                                \
    }                                           \
    x = result;                                 \
}

#define mod_integer(Rep, x, y)                  \
{                                               \
    Rep result = x % y;                         \
    if (result && (x^y) < 0)                    \
        result += y;                            \
    x = result;                                 \
}

#define rem_integer(Rep, x, y)          x = x % y
#define pow_integer(Rep, x, y)                  \
{                                               \
    Rep result = y >= 0 ? 1 : 0;                \
    while (y > 0)                               \
    {                                           \
        if (y & 1)                              \
            result *= x;                        \
        x *= x;                                 \
        y >>= 1;                                \
    }                                           \
    x = result;                                 \
}

#define mod_real(Rep, x, y)                     \
    {                                           \
    Rep result = fmod(x, y);                    \
    if (result != 0.0 && x*y < 0.0)             \
        result += y;                            \
    x = result;                                 \
}
#define rem_real(Rep, x, y)             x = fmod(x,y)
#define pow_real(Rep, x, y)             x = pow(x,y);


#define ARITH(Name, R, BC)                                              \
    BUILTIN(add_##Name, (),     x_##BC = R(R(x_##BC) + R(y_##BC)))      \
    BUILTIN(sub_##Name, (),     x_##BC = R(R(x_##BC) - R(y_##BC)))      \
    BUILTIN(mul_##Name, (),     x_##BC = R(R(x_##BC) * R(y_##BC)))      \
    DIVIDER(div_##Name, BC,     x_##BC = R(R(x_##BC) / R(y_##BC)))      \
    DIVIDER(mod_##Name, BC,     mod_##BC(R, x_##BC, y_##BC))            \
    DIVIDER(rem_##Name, BC,     rem_##BC(R, x_##BC, y_##BC))            \
    BUILTIN(pow_##Name, (),     pow_##BC(R, x_##BC, y_##BC))

#define SHIFTS(Name, R, BC)                                             \
    BUILTIN(shl_##Name, (),     x_##BC = R(R(x_##BC) << R(y_##BC)))     \
    BUILTIN(shr_##Name, (),     x_##BC = R(R(x_##BC) >> R(y_##BC)))

#define LOGICAL(Name, R, BC)                                            \
    BUILTIN(and_##Name, (),     x_##BC = R(R(x_##BC) & R(y_##BC)))      \
    BUILTIN( or_##Name, (),     x_##BC = R(R(x_##BC) | R(y_##BC)))      \
    BUILTIN(xor_##Name, (),     x_##BC = R(R(x_##BC) ^ R(y_##BC)))

#define COMPARE(Name, R, BC)                                            \
    BUILTIN(eq_##Name, (), x_boolean = x_##BC == y_##BC; TYPE(boolean)) \
    BUILTIN(ne_##Name, (), x_boolean = x_##BC != y_##BC; TYPE(boolean)) \
    BUILTIN(lt_##Name, (), x_boolean = x_##BC <  y_##BC; TYPE(boolean)) \
    BUILTIN(gt_##Name, (), x_boolean = x_##BC  > y_##BC; TYPE(boolean)) \
    BUILTIN(le_##Name, (), x_boolean = x_##BC <= y_##BC; TYPE(boolean)) \
    BUILTIN(ge_##Name, (), x_boolean = x_##BC >= y_##BC; TYPE(boolean))

#define NATURAL_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, natural)                 \
    SHIFTS(Name,  Rep, natural)                 \
    LOGICAL(Name, Rep, natural)                 \
    COMPARE(Name, Rep, natural)

#define INTEGER_TYPE(Name, Rep)                 \
    ARITH(Name,   Rep, integer)                 \
    SHIFTS(Name,  Rep, integer)                 \
    LOGICAL(Name, Rep, integer)                 \
    COMPARE(Name, Rep, integer)

#define REAL_TYPE(Name, Rep)                    \
    ARITH(Name,   Rep, real)                    \
    COMPARE(Name, Rep, real)

#include "machine-types.tbl"

LOGICAL(boolean, bool, boolean)
COMPARE(boolean, bool, boolean)

COMPARE(text, text, text)
BUILTIN(concat, (),     x_text = x_text + y_text)



// ============================================================================
//
//   General evaluation opcodes
//
// ============================================================================

OPCODE(evaluate, (),
// ----------------------------------------------------------------------------
//   Evaluate x in current scope
// ----------------------------------------------------------------------------
       WANT_XTREE;
       x_tree = evaluate(scope, x_tree);
       CLASSIFY;
)


OPCODE(cast, (),
// ----------------------------------------------------------------------------
//   Cast the value x to type y
// ----------------------------------------------------------------------------
       WANT_XTREE;
       x_tree = typecheck(scope, y_tree, x_tree);
       CLASSIFY;
)


OPCODE(error, (CONSTANT),
// ----------------------------------------------------------------------------
//   Emit an error with the given arguments (not evaluated)
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       x_tree = new Prefix(error_type, x_tree);
       xtype = error_mtype;
)


OPCODE(error_exit, (CONSTANT),
// ----------------------------------------------------------------------------
//   Exit evaluation immediately with an error
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       x_tree = new Prefix(error_type, x_tree);
       xtype = error_mtype;
       return x_tree;
)


OPCODE(exit, (),
// ----------------------------------------------------------------------------
//   Terminate execution
// ----------------------------------------------------------------------------
       WANT_XTREE;
       return x_tree;
)


OPCODE(native, (CONSTANT_natural, ARGUMENTS),
// ----------------------------------------------------------------------------
//   Call a native function
// ----------------------------------------------------------------------------
       Natural::value_t addr = Constant<Natural::value_t>(pc);
       Native::opcode_fn fn = (Native::opcode_fn) addr;

       // Read arguments
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           opcode_t index = DATA;
           state.Push(frame[index]);
       }

       fn(state);
       x = state.Pop();
       CLASSIFY;
)


OPCODE(x_to_y, (),
// ----------------------------------------------------------------------------
//   Copy X to Y
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;
       y = x;
       READ_RUNVALUES;
)



OPCODE(swap, (),
// ----------------------------------------------------------------------------
//   Swap X and Y
// ----------------------------------------------------------------------------
       WANT_RUNVALUES;
       std::swap(x,y);
       READ_RUNVALUES;
)



OPCODE(check_statement, (),
// ----------------------------------------------------------------------------
//   If we have an error on top of stack, exit, otherwise check we have nil
// ----------------------------------------------------------------------------
       if (xtype == error_mtype)
           CHAIN(ret);
       if (xtype != nil_mtype)
       {
           Error error("Non-nil result from statement");
           state.Error(error);
           xtype = error_mtype;
           CHAIN(ret);
       }
)


OPCODE(branch, (JUMP),
// ----------------------------------------------------------------------------
//   Branch to the given target
// ----------------------------------------------------------------------------
       opcode_t offset = DATA;
       pc += offset;
)


OPCODE(nil, (),
// ----------------------------------------------------------------------------
//   Generate a nil value
// ----------------------------------------------------------------------------
       x_tree = nullptr;
       TYPE(nil);
)


OPCODE(true, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x_boolean = true;
       TYPE(boolean);
)


OPCODE(false, (),
// ----------------------------------------------------------------------------
//   Generate constant true
// ----------------------------------------------------------------------------
       x_boolean = false;
       TYPE(boolean);
)


OPCODE(constant, (CONSTANT),
// ----------------------------------------------------------------------------
//   Deposit a constant tree on the stack
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       TYPE(tree);
       CLASSIFY;
)


OPCODE(rewrite, (DEFINITION),
// ----------------------------------------------------------------------------
//   Deposit a rewrite on the stack
// ----------------------------------------------------------------------------
       x_tree = Definition(DATA);
       TYPE(tree);
       CLASSIFY;
)


// ----------------------------------------------------------------------------
// Constants for the various representation types
// ----------------------------------------------------------------------------
#define TREE_TYPE(Name, Rep, Cast)
#define RUNTIME_TYPE(Name, Rep, BC)             \
OPCODE(constant_##Name, (CONSTANT_##Name),      \
       x_##BC = Constant<Rep>(pc);              \
       TYPE(Name);                              \
)
#include "machine-types.tbl"


OPCODE(make_variable, (),
// ----------------------------------------------------------------------------
//   Turn a tree into a variable tree
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree *type = x_tree;
       if (!IsVariableType(type))
       {
           type = new Prefix(xl_variable, type, type->Position());
           x_tree = type;
           TYPE(prefix);
       }
)


OPCODE(make_matching, (),
// ----------------------------------------------------------------------------
//   Turn something into a pattern matching type
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree *type = x_tree;
       if (!IsPatternMatchingType(type))
       {
           type = new Prefix(xl_matching, type, type->Position());
           x_tree = type;
           TYPE(prefix);
       }
)


OPCODE(get_scope, (),
// ----------------------------------------------------------------------------
//   Return current scope
// ----------------------------------------------------------------------------
       x_tree = state.EvaluationScope();
       TYPE(scope);
)


OPCODE(get_super, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       x_tree = state.EvaluationScope()->Enclosing();
       TYPE(scope);
)


OPCODE(get_self, (),
// ----------------------------------------------------------------------------
//   Return super scope
// ----------------------------------------------------------------------------
       x_tree = state.self;
       CLASSIFY;
)


OPCODE(set_scope, (),
// ----------------------------------------------------------------------------
//   Set the scope
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Scope *scope = x_tree->As<Scope>();
       if (!scope)
           record(opcode_error, "set_scope received non-scope %t", x_tree);
       state.scope = scope;
)


OPCODE(enter, (),
// ----------------------------------------------------------------------------
//   Enter a nested scope
// ----------------------------------------------------------------------------
       Context context(state.scope);
       state.scope = context.CreateScope();
       locals = state.Depth();
       REFRAME;
)


OPCODE(call_constant, (CONSTANT, ARGUMENTS),
// ----------------------------------------------------------------------------
//   Call a constant tree
// ----------------------------------------------------------------------------
       x_tree = Constant(DATA);
       CHAIN(call);
)


OPCODE(call, (ARGUMENTS),
// ----------------------------------------------------------------------------
//    Call X with the given arguments
// ----------------------------------------------------------------------------
       // Push PC and locals value
       state.Push(RunValue(pc, runvalue_pc));
       state.Push(RunValue(locals, runvalue_locals));
       state.Push(RunValue(bc, runvalue_bytecode));

       size_t base = state.Depth();
       size_t nargs = DATA;
       for (size_t a = 0; a < nargs; a++)
       {
           REFRAME;
           opcode_t index = DATA;
           state.Push(frame[index]);
       }
       pc = 0;
       bc = x_tree->GetInfo<Bytecode>();
       if (!bc)
       {
           record(opcode_error, "Calling %t which was not compiled", x_tree);
           return nullptr;
       }
       XL_ASSERT(bc->parameters.size() == nargs);
       locals = base;
       state.Allocate(bc->locals); // Add locals on top of arguments

       REFRAME;
       RETARGET;
)


OPCODE(ret, (),
// ----------------------------------------------------------------------------
//    Return to caller, returning the result as X in RunValue as is
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;

       state.Cut(locals);
       if (locals)
       {
           bc = (Bytecode *) state.Pop(runvalue_bytecode).as_natural;
           locals = state.Pop(runvalue_locals).as_natural;
           pc = state.Pop(runvalue_pc).as_natural;
       }
       else
       {
           return x.AsTree();
       }
       RETARGET;
)


OPCODE(assign, (),
// ----------------------------------------------------------------------------
//   Perform an assignment X := Y
// ----------------------------------------------------------------------------
       WANT_TREES;

       Rewrite_p rewrite = x_tree->As<XL::Rewrite>();
       if (rewrite)
       {
           rewrite->right = y_tree;
           TYPE(nil);
       }
       else
       {
           Error error("Cannot assign to non-variable $1", x_tree);
           state.Error(error);
           x_tree = error;
           TYPE(error);
       }
)


OPCODE(store, (LOCAL),
// ----------------------------------------------------------------------------
//   Save X to a local storage (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       WANT_XRUNVALUE;
       opcode_t index = DATA;
       frame[index] = x;
)


OPCODE(load, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value (0..nparms: Parameters; then local storage)
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       x = frame[index];
       READ_XRUNVALUE;
)


OPCODE(load_y, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value into y
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       y = frame[index];
       READ_YRUNVALUE;
)


OPCODE(push_local, (LOCAL),
// ----------------------------------------------------------------------------
//   Load a local value and push it on top of stack (for native functions)
// ----------------------------------------------------------------------------
       opcode_t index = DATA;
       state.Push(frame[index]);
       REFRAME;
)


OPCODE(pop, (),
// ----------------------------------------------------------------------------
//   Load a local value and push it on top of stack (for native functions)
// ----------------------------------------------------------------------------
       x = state.Pop();
       READ_XRUNVALUE;
)


OPCODE(init_value, (DEFINITION),
// ----------------------------------------------------------------------------
//   Initialize a named constant
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Rewrite_p rewrite = bc->Definition(DATA);
       rewrite->right = x_tree;
)


// ============================================================================
//
//    Checks - Branch to target in case of failure, leave value in X
//
// ============================================================================

OPCODE(check_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check a type at runtime
// ----------------------------------------------------------------------------
       WANT_XTREE;
       Tree_p value = x_tree;
       Tree_p type = Constant(DATA);
       opcode_t branch = DATA;
       x_tree = typecheck(state.scope, type, value);
       if (!x_tree)
           pc += branch;
       CLASSIFY;
)


OPCODE(check_input_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an input argument
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_result_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an argument
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_init_type, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check the type of an initializer
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_typecast, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Evaluate a type cast, i.e. [X as Y]
// ----------------------------------------------------------------------------
       CHAIN(check_type);
)


OPCODE(check_guard, (JUMP),
// ----------------------------------------------------------------------------
//   Check if the guard condition is true, or nullify the stack
// ----------------------------------------------------------------------------
       opcode_t branch = DATA;
       if (xtype != boolean_mtype || !x_boolean)
           pc += branch;
)


OPCODE(check_same, (JUMP),
// ----------------------------------------------------------------------------
//   Check if X and Y match, if not branch to taget
// ----------------------------------------------------------------------------
       WANT_TREES;
       opcode_t branch = DATA;
       if (!Tree::Equal(x_tree, y_tree))
           pc += branch;
)


OPCODE(check_natural, (CONSTANT_natural, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a natural constant
// ----------------------------------------------------------------------------
       uintptr_t ref = Constant<Natural::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != natural_mtype || x_natural != ref)
           pc += branch;
)


OPCODE(check_real, (CONSTANT_real, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a real constant
// ----------------------------------------------------------------------------
       double ref = Constant<Real::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != real_mtype || x_real != ref)
           pc += branch;
)


OPCODE(check_text, (CONSTANT_text, JUMP),
// ----------------------------------------------------------------------------
//   Check if we match a text constant
// ----------------------------------------------------------------------------
       text ref = Constant<Text::value_t>(pc);
       opcode_t branch = DATA;
       if (xtype != text_mtype || x_text != ref)
           pc += branch;
)


OPCODE(check_infix, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//   Check if we have an infix, and if so, split it into two components
// ----------------------------------------------------------------------------
//   We have [infix], we will have either [right, left], or [nullptr]
       WANT_XTREE;

       Tree *ref = Constant(DATA);
       opcode_t offset = DATA;
       Infix *refinfix = ref->AsInfix();
       if (!refinfix)
       {
           record(opcode_error, "check_infix with non-infix reference %t", ref);
           return nullptr;
       }
       Infix *infix = x_tree->AsInfix();
       if (!infix || infix->name != refinfix->name)
           pc += offset;
       else
           xtype = infix_mtype;
)


OPCODE(check_borrow, (JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration
// ----------------------------------------------------------------------------
       opcode_t offset = DATA;
       Rewrite *rewrite = x_tree->As<Rewrite>();
       if (!rewrite)
           pc += offset;
       else
           xtype = definition_mtype;
)


OPCODE(check_typed_borrow, (CONSTANT, JUMP),
// ----------------------------------------------------------------------------
//    Borrow a variable declaration and check its type
// ----------------------------------------------------------------------------
       Tree_p type = Constant(DATA);
       opcode_t offset = DATA;
       Rewrite *rewrite = x_tree->As<Rewrite>();
       bool ok = false;
       if (rewrite)
       {
           xtype = definition_mtype;

           Infix *vartype = IsTypeAnnotation(rewrite->left);
           Tree_p have = vartype->right;
           if (Tree::Equal(type, have))
               ok = true;
       }
       if (!ok)
           pc += offset;
)

#undef OPCODE
#undef BUILTIN
