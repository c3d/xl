// *****************************************************************************
// compiler-function.cpp                                              XL project
// *****************************************************************************
//
// File description:
//
//     A function generated in a CompilerUnit
//
//     There are, broadly, two kinds of functions being generated:
//     1. CompilerEval functions, with evalTy as their signature (aka eval_fn)
//     2. CompilerFunction Optimized functions, with arbitrary signatures.
//
//     Optimized functions have a 'closure type' as their first argument
//     if symbols from surrounding contexts were captured during analysis
//
//
//
// *****************************************************************************
// This software is licensed under the GNU General Public License v3+
// (C) 2018-2021, Christophe de Dinechin <christophe@dinechin.org>
// *****************************************************************************
// This file is part of XL
//
// XL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// XL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with XL, in a file named COPYING.
// If not, see <https://www.gnu.org/licenses/>.
// *****************************************************************************

#include "compiler-function.h"
#include "compiler-expr.h"
#include "errors.h"
#include "builtins.h"
#include <stdint.h>


RECORDER(compiler_function, 64, "Functions generated by the compiler");
RECORDER(parameter_bindings, 64, "Looking up parameters in functions");

XL_BEGIN

CompilerFunction::CompilerFunction(CompilerUnit &unit,
                                   Tree *pattern,
                                   Tree *body,
                                   CompilerTypes *types,
                                   JIT::FunctionType_p ftype,
                                   text name)
// ----------------------------------------------------------------------------
//   Create new compiler function for standard evaluation functions (eval_fn)
// ----------------------------------------------------------------------------
//  This is used for a top-level function, which is turned into an eval_fn
//  There is no closure since nothing can be captured from enclosing scope
    : CompilerPrototype(unit, pattern, types, ftype, name),
      compiler(unit.compiler),
      jit(unit.jit),
      body(body),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function)),
      closure(nullptr)
{
    InitializeArgs();
    record(compiler_function, "Created %p for %t in %p value %v",
           this, pattern, types, function);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   CompilerRewriteCandidate *rc)
// ----------------------------------------------------------------------------
//   Create new compiler function for optimized evaluation functions
// ----------------------------------------------------------------------------
//   This is used by rewrites like [Pattern is Body].
//   In that case, 'parms' have been generated to match [Pattern] free parms,
//   and we build a closure type if [Body] had captures from the environment
    : CompilerPrototype(caller, rc),
      compiler(caller.compiler),
      jit(caller.jit),
      body(rc->RewriteBody()),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function)),
      closure(nullptr)
{
    InitializeArgs(rc);
    record(compiler_function,
           "Created optimized %p called by %p for %t function %v",
           this, &caller, pattern, function);
}


CompilerFunction::~CompilerFunction()
// ----------------------------------------------------------------------------
//   Delete compiler function
// ----------------------------------------------------------------------------
{
    record(compiler_unit, "Deleted function %p for %t", this, pattern);
}


CompilerFunction::Primitives CompilerFunction::primitives;
CompilerFunction::MachineTypes CompilerFunction::mtypes;


void CompilerFunction::InitializePrimitives()
// ----------------------------------------------------------------------------
//   Initialize the primitives if the primitives table is empty
// ----------------------------------------------------------------------------
{
    if (primitives.size())
        return;

#define MTYPE(Name, Arity, Code)                                        \
    mtypes[#Name] = MachineTypeInfo {                                   \
        &CompilerFunction::llvm_type_##Name,                            \
        Arity                                                           \
    };
#define UNARY(Name)                                                     \
    primitives[#Name] = PrimitiveInfo {                                 \
        &CompilerFunction::llvm_##Name,                                 \
        1                                                               \
    };
#define BINARY(Name)                                                    \
    primitives[#Name] = PrimitiveInfo {                                 \
        &CompilerFunction::llvm_##Name,                                 \
        2                                                               \
    };
#define CAST(Name)                                                      \
    primitives[#Name] = PrimitiveInfo {                                 \
        &CompilerFunction::llvm_##Name,                                 \
        2                                                               \
    };
#define SPECIAL(Name, Arity, Code)                                      \
    primitives[#Name] = PrimitiveInfo {                                 \
        &CompilerFunction::llvm_##Name,                                 \
        Arity                                                           \
    };
#define ALIAS(To, Arity, From)                                          \
    primitives[#To] = PrimitiveInfo {                                   \
        &CompilerFunction::llvm_##From,                                 \
        Arity                                                           \
    };
#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"
}


bool CompilerFunction::IsInterfaceOnly()
// ----------------------------------------------------------------------------
//   Check if the function is an interface-only function (for C calls)
// ----------------------------------------------------------------------------
{
    return entry == nullptr;
}


JIT::Function_p CompilerFunction::Compile(Tree *tree, bool force)
// ----------------------------------------------------------------------------
//    Compile a given tree in given function and return the associated value
// ----------------------------------------------------------------------------
{
    CompilerExpression expr(*this);
    JIT::Value_p result = expr.Evaluate(tree, force);
    if (returned)
        Return(tree, result);
    return function;
}


JIT::Value_p CompilerFunction::Return(Tree *tree, JIT::Value_p value)
// ----------------------------------------------------------------------------
//   Return the given value, after appropriate boxing
// ----------------------------------------------------------------------------
{
    JIT::Type_p retTy = jit.ReturnType(function);
    value = Autobox(tree, value, retTy);

    JIT::Type_p valTy = JIT::Type(value);
    if (valTy == retTy)
        code.Store(value, returned);
    return value;
}


eval_fn CompilerFunction::Finalize(bool createCode)
// ----------------------------------------------------------------------------
//   Finalize the build of the current function
// ----------------------------------------------------------------------------
{
    record(llvm, "Finalize function %v", function);

    // Branch to the exit block from the current main body of code
    code.Branch(exit);

    // Connect the "allocas" data prologue to the actual entry point
    data.Branch(entry);

    // Insert return in exit block
    if (returned)
    {
        JIT::Value_p retVal = exit.Load(returned, "retval");
        exit.Return(retVal);
    }
    else
    {
        exit.Return(nullptr);
    }

    // Verify the function we built
    if (RECORDER_TRACE(llvm_code) & 1)
        jit.Print("LLVM IR before verification and optimizations:\n", function);
    if (jit.VerifyFunction(function))
    {
        Ooops("Generated code verification failed for $1 (internal)", pattern);
        return nullptr;
    }
    jit.Finalize(function);
    if (RECORDER_TRACE(llvm_code) & 2)
        jit.Print("LLVM IR after optimizations:\n", function);

    void *result = nullptr;
    if (createCode)
    {
        result = jit.ExecutableCode(function);
        if (RECORDER_TRACE(llvm_code) & 4)
            jit.Print("LLVM IR after machine code generation:\n", function);
    }

    record(llvm_functions, "Function code %p for %v", result, function);
    return (eval_fn) result;
}


void CompilerFunction::InitializeArgs()
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for eval functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are (Scope *scope, Tree *self)
{
    // Associate the value for the additional arguments (read-only, no alloca)
    JITArguments args(function);
    JIT::Value_p scope = *args++;
    JIT::Value_p self = *args++;

    // Insert 'self', mapping to pattern, and 'scope' for the evaluation scope
    values[scope_type] = scope;
    values[xl_self] = self;
}


void CompilerFunction::InitializeArgs(CompilerRewriteCandidate *rc)
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for optimized functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are from the function itself
//   They may start with a closure pointer, which we read here to have
//   the values set during the rest of the code generation
{
    // Associate the value for the additional arguments (read-only, no alloca)
    JITArguments inputs(function);

    // Read the actual parameters
    for (RewriteBinding &binding : rc->bindings)
    {
        JIT::Value_p input = *inputs++;
        values[binding.name] = input;
    }

    // Insert 'self', mapping to pattern, and 'scope' for the evaluation scope
    Scope *scope = rc->value_types->TypesScope();
    Tree *pattern = rc->RewritePattern();
    values[scope_type] = data.PointerConstant(compiler.scopePtrTy, scope);
    values[xl_self] = data.PointerConstant(compiler.treePtrTy, pattern);
}


JIT::Value_p CompilerFunction::Compile(Tree *call,
                                       CompilerRewriteCandidate *rc,
                                       const JIT::Values &args)
// ----------------------------------------------------------------------------
//    Compile a given rewrite for a tree
// ----------------------------------------------------------------------------
{
    // Check if cache already contains a compilation for this function
    Scope *scope = types->TypesScope();
    JIT::Function_p &function = unit.Compiled(scope, rc, args);
    if (function == nullptr)
    {
        Tree *body = rc->RewriteBody();

        // Check if we have C or data patterns
        CompilerTypes::Decl d = CompilerTypes::RewriteCategory(rc);
        bool isC = d == CompilerTypes::Decl::C;
        bool isData = d == CompilerTypes::Decl::DATA;

        // Identify the return type for the rewrite
        CompilerTypes *btypes = rc->BindingTypes();
        Tree *base = btypes->BaseType(rc->type);
        JIT::Type_p retTy = rc->RewriteType();
        if (!retTy && rc->type)
        {
            retTy = BoxedType(base);
            if (retTy)
            {
                btypes->AddBoxedType(base, retTy);
                rc->RewriteType(retTy);
            }
        }
        if (!retTy)
        {
            if (isData)
                retTy = StructureType(rc->RewriteSignature(),
                                      rc->RewritePattern(),
                                      base);
            else
                retTy = ValueMachineType(rc->RewritePattern(), true);
            if (!retTy)
                retTy = jit.VoidType();
            rc->RewriteType(retTy);
        }

        if (isC)
        {
            CompilerPrototype proto(*this, rc);
            function = proto.Function();
        }
        else
        {
            CompilerFunction evalfn(*this, rc);

            // Make sure we don't recompile in case of recursive evaluation
            function = evalfn.Function();

            // Compile the body
            if (!isData)
            {
                // Regular function body: compile it
                evalfn.Compile(body);
            }
            else
            {
                // Constructor for a 'data' form, e.g. [X,Y is self]
                unsigned index = 0;
                Tree *pattern = PatternBase(rc->RewritePattern());
                JIT::Value_p box = evalfn.returned;
                JIT::Value_p retv = evalfn.Data(pattern, box, index);
                evalfn.Return(body, retv);
            }

            evalfn.Finalize(false);
        }
    }

    return function;
}


JIT::Value_p CompilerFunction::Data(Tree *expr,
                                    JIT::Value_p box,
                                    unsigned &index)
// ----------------------------------------------------------------------------
//    Generate a constructor for a data pattern, e.g. [X,Y is self]
// ----------------------------------------------------------------------------
{
    JIT::Value_p left, right, child;

    switch(expr->Kind())
    {
    case NATURAL:
    case REAL:
    case TEXT:
    {
        // For all these cases, simply compute the corresponding value
        CompilerExpression subexpr(*this);
        JIT::Value_p result = subexpr.Evaluate(expr);
        JIT::Value_p ptr = code.StructGEP(box, index++, "resultp");
        result = code.Store(result, ptr);
        return result;
    }

    case NAME:
    {
        // Bound names are returned as is, parameters are evaluated
        Context *context = types->TypesContext();
        record(parameter_bindings, "Looking up %t in context %p",
               expr, (Context *) context);
        Tree *existing = context->DeclaredPattern(expr);
        assert (existing || !"TypeAnalysis didn't realize a name was missing");

        // Arguments bound here are returned directly as a tree
        if (JIT::Value_p result = Known(existing))
        {
            // Store that in the result tree
            JIT::Value_p ptr = code.StructGEP(box, index++, "resultp");
            result = code.Store(result, ptr);
            return result;
        }

        // Arguments not bound here are returned as a constant
        return ConstantTree(existing);
    }

    case INFIX:
    {
        Infix *infix = (Infix *) expr;
        left = Data(infix->left, box, index);
        right = Data(infix->right, box, index);
        return right;
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) expr;
        if (prefix->left->Kind() != NAME)
            left = Data(prefix->left, box, index);
        right = Data(prefix->right, box, index);
        return right;
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) expr;
        if (postfix->right->Kind() != NAME)
            right = Data(postfix->right, box, index);
        left = Data(postfix->left, box, index);
        return left;
    }

    case BLOCK:
    {
        Block *block = (Block *) expr;
        child = Data(block->child, box, index);
        return child;
    }
    }

    assert (!"Unknown kind of tree in Data()");
    return ConstantTree(expr);
}


JIT::Value_p CompilerFunction::Autobox(Tree *source,
                                       JIT::Value_p value,
                                       JIT::Type_p req)
// ----------------------------------------------------------------------------
//   Automatically box/unbox types
// ----------------------------------------------------------------------------
//   Primitive values like naturals can exist in two forms during execution:
//   - In boxed form, e.g. as a pointer to an instance of Natural
//   - In native form, e.g. as an natural
//   This function automatically converts from one to the other as necessary
{
    JIT::Type_p     type   = JIT::Type(value);
    JIT::Value_p    result = value;
    JIT::Function_p boxFn  = nullptr;

    // Short circuit if we are already there
    if (req == type)
        return result;

    // Unboxing cases
    if (req == compiler.booleanTy)
    {
        assert (type == compiler.treePtrTy || type == compiler.nameTreePtrTy);
        JIT::Value_p falsePtr = ConstantTree(xl_false);
        result = code.ICmpNE(value, falsePtr, "notfalse");
    }
    else if (req->isIntegerTy())
    {
        if (req == compiler.characterTy && type == compiler.textTreePtrTy)
        {
            // Convert text constant to character
            result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
            result = code.StructGEP(result, 0, "ubox_charpp");
            result = code.StructGEP(result, 0, "ubox_charp");
            result = code.Load(result, "ubox_char");
        }
        else
        {
            // Convert natural constants
            assert (type == compiler.naturalTreePtrTy);
            result = code.StructGEP(value, NATURAL_VALUE_INDEX, "ubox_int");
            if (req != compiler.naturalTy)
                result = code.Trunc(result, req);
        }
    }
    else if (req->isFloatingPointTy())
    {
        assert(type == compiler.realTreePtrTy);
        result = code.StructGEP(value, REAL_VALUE_INDEX, "ubox_real");
        if (req != compiler.realTy)
            result = code.FPTrunc(result, req);
    }
    else if (req == compiler.charPtrTy)
    {
        assert(type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
        result = code.StructGEP(result, 0, "ubox_charpp");
        result = code.Load(result, "ubox_charp");
    }
    else if (req == compiler.textTy || req == compiler.textPtrTy)
    {
        assert (type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
    }

    // Boxing cases
    else if (type == compiler.booleanTy)
    {
        assert(req == compiler.nameTreePtrTy || req == compiler.treePtrTy);
        JIT::Value_p truep = code.PointerConstant(compiler.nameTreePtrTy,
                                                  xl_true);
        JIT::Value_p falsep = code.PointerConstant(compiler.nameTreePtrTy,
                                                   xl_false);
        result = code.Select(value, truep, falsep);
    }
    else if (type == compiler.characterTy &&
             (req == compiler.treePtrTy || req == compiler.textTreePtrTy))
    {
        boxFn = unit.xl_new_character;
    }
    else if (type->isIntegerTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.naturalTreePtrTy);
        boxFn = unit.xl_new_natural;
        if (type != compiler.ulonglongTy)
            result = code.SExt(result, compiler.ulonglongTy); // REVISIT: Sign?
    }
    else if (type->isFloatingPointTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.realTreePtrTy);
        boxFn = unit.xl_new_real;
        if (type != compiler.realTy)
            result = code.FPExt(result, type);
    }
    else if (type == compiler.textTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_text;
    }
    else if (type == compiler.textPtrTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_text_ptr;
    }
    else if (type == compiler.charPtrTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_ctext;
    }
    else if (req == compiler.blockTreePtrTy   ||
             req == compiler.infixTreePtrTy   ||
             req == compiler.prefixTreePtrTy  ||
             req == compiler.postfixTreePtrTy ||
             req == compiler.treePtrTy)
    {
        boxFn = unit.CompiledUnbox(type);
        if (boxFn)
        {
            JIT::Value_p storage = NeedStorage(source, type);
            code.Store(result, storage);
            result = storage;
        }
    }

    // If we need to invoke a boxing function, do it now
    if (boxFn)
    {
        uint64_t pos = source->Position();
        JIT::Value_p posValue = code.IntegerConstant(compiler.ulongTy, pos);
        result = code.Call(boxFn, posValue, result);
    }
    type = JIT::Type(result);

    // Check if a tree type cast is required
    if (req == compiler.treePtrTy && type != req)
    {
        if (type == compiler.naturalTreePtrTy ||
            type == compiler.realTreePtrTy    ||
            type == compiler.textTreePtrTy    ||
            type == compiler.nameTreePtrTy    ||
            type == compiler.blockTreePtrTy   ||
            type == compiler.prefixTreePtrTy  ||
            type == compiler.postfixTreePtrTy ||
            type == compiler.infixTreePtrTy)
            result = code.BitCast(result, req);
        else
            // If there was some inconsistency, return an error
            result = ConstantTree(nullptr);
    }

    // Return what we built if anything
    return result;
}


JIT::Function_p CompilerFunction::UnboxFunction(JIT::Type_p type,
                                                Tree *pattern)
// ----------------------------------------------------------------------------
//    Create a function transforming a boxed (structure) value into tree form
// ----------------------------------------------------------------------------
{
    // Check if we have a matching boxing function
    JIT::Function_p &function = unit.CompiledUnbox(type);

    if (!function)
    {
        if (Tree *inner = types->IsPatternType(pattern))
            pattern = inner;

        // Get original form representing that data type
        JIT::Type_p mtype = compiler.treePtrTy;
        JIT::Type_p ptype = unit.jit.PointerType(type);

        // Create a function that looks like [Tree *unboxfn(boxtype *)]
        JIT::Signature sig { compiler.ulongTy, ptype };
        JIT::FunctionType_p fty = jit.FunctionType(mtype, sig);
        CompilerFunction unbox(unit, pattern, pattern, types, fty, "xl.unbox");

        // Find the first input argument, which is the boxed value pointer
        function = unbox.Function();
        auto args = function->arg_begin();
        JIT::Value_p position = &*args++; // Ignored?
        JIT::Value_p arg = &*args++;

        // Generate the code to create the unboxed tree
        unsigned index = 0;
        JIT::Value_p rval = unbox.Unbox(arg, pattern, index);
        rval = unbox.Autobox(pattern, rval, mtype);
        unbox.Return(pattern, rval);

        // Finalize the unbox function
        unbox.Finalize(false);

        record(types_boxing, "Created %T unboxing function %v for %t pos %v",
               mtype, unbox.function, pattern, position);

    }

    return function;
}


JIT::Value_p CompilerFunction::Unbox(JIT::Value_p boxed,
                                     Tree *pattern,
                                     uint &index)
// ----------------------------------------------------------------------------
//   Recursively generate code to unbox a value within UnboxFunction
// ----------------------------------------------------------------------------
{
    JIT::Type_p ttp = compiler.treePtrTy;
    JIT::Value_p ref, left, right, child;

    switch(pattern->Kind())
    {
    default:
        assert(!"Invalid tree kind in CompilerFunction::Unbox");

    case NATURAL:
    case REAL:
    case TEXT:
    {
        // Constant values in the pattern can be returned as is
        return ConstantTree(pattern);
    }

    case NAME:
    {
        // Get element from input argument
        JIT::Value_p result = code.StructGEP(boxed, index++, "boxedp");
        result = code.Load(result);
        return result;
    }

    case INFIX:
    {
        Infix *infix = (Infix *) pattern;
        if (IsTypeAnnotation(infix) || IsPatternCondition(infix))
            return Unbox(boxed, infix->left, index);
        ref = ConstantTree(infix);
        ref = code.BitCast(ref, compiler.infixTreePtrTy);
        left = Unbox(boxed, infix->left, index);
        right = Unbox(boxed, infix->right, index);
        left = Autobox(infix->left, left, ttp);
        right = Autobox(infix->right, right, ttp);
        return code.Call(unit.xl_new_infix, ref, left, right);
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) pattern;
        ref = ConstantTree(prefix);
        ref = code.BitCast(ref, compiler.prefixTreePtrTy);
        if (prefix->left->Kind() == NAME)
            left = ConstantTree(prefix->left);
        else
            left = Unbox(boxed, prefix->left, index);
        right = Unbox(boxed, prefix->right, index);
        left = Autobox(prefix->left, left, ttp);
        right = Autobox(prefix->right, right, ttp);
        return code.Call(unit.xl_new_prefix, ref, left, right);
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) pattern;
        ref = ConstantTree(postfix);
        ref = code.BitCast(ref, compiler.postfixTreePtrTy);
        left = Unbox(boxed, postfix->left, index);
        if (postfix->right->Kind() == NAME)
            right = ConstantTree(postfix->right);
        else
            right = Unbox(boxed, postfix->right, index);
        left = Autobox(postfix->left, left, ttp);
        right = Autobox(postfix->right, right, ttp);
        return code.Call(unit.xl_new_postfix, ref, left, right);
    }

    case BLOCK:
    {
        Block *block = (Block *) pattern;
        ref = ConstantTree(block);
        ref = code.BitCast(ref, compiler.blockTreePtrTy);
        child = Unbox(boxed, block->child, index);
        child = Autobox(block->child, child, ttp);
        return code.Call(unit.xl_new_block, ref, child);
    }
    }
}


JIT::Value_p CompilerFunction::NeedStorage(Tree *tree, JIT::Type_p mtype)
// ----------------------------------------------------------------------------
//    Allocate storage for a given tree
// ----------------------------------------------------------------------------
{
    JIT::Value_p result = storage[tree];
    if (!result)
    {
        // Get the associated machine type
        if (!mtype)
            mtype = ValueMachineType(tree);

        // Create alloca to store the new form
        result = data.Alloca(mtype, "loc");
        storage[tree] = result;

        // If this started with a value, initialize it here
        if (values.count(tree))
        {
            JIT::Value_p initializer = values[tree];
            assert(initializer && initializer->getType() == mtype);
            code.Store(initializer, result);
        }
    }

    return result;
}


bool CompilerFunction::IsKnown(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Check if the tree has a known local or global value
// ----------------------------------------------------------------------------
{
    if ((which & knowLocals) && storage.count(tree) > 0)
        return true;
    else if ((which & knowValues) && values.count(tree) > 0)
        return true;
    else if ((which & knowGlobals) && unit.globals.count(tree) > 0)
        return true;
    return false;
}


JIT::Value_p CompilerFunction::Known(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Return the known local or global value if any
// ----------------------------------------------------------------------------
{
    if (which & knowLocals)
    {
        auto it = storage.find(tree);
        if (it != storage.end())
            return code.Load(it->second, "loc");
    }
    if (which & knowValues)
    {
        auto it = values.find(tree);
        if (it != values.end())
            return it->second;
    }
    if (which & knowGlobals)
    {
        auto it = unit.globals.find(tree);
        if (it != unit.globals.end())
            return code.Load(it->second, "glob");
    }
    return nullptr;
}


JIT::Value_p CompilerFunction::ConstantNatural(Natural *what)
// ----------------------------------------------------------------------------
//    Generate an Natural tree
// ----------------------------------------------------------------------------
{
    JIT::Value_p result = code.PointerConstant(compiler.naturalTreePtrTy, what);
    return result;
}


JIT::Value_p CompilerFunction::ConstantReal(Real *what)
// ----------------------------------------------------------------------------
//    Generate a Real tree
// ----------------------------------------------------------------------------
{
    JIT::Value_p result = code.PointerConstant(compiler.realTreePtrTy, what);
    return result;
}


JIT::Value_p CompilerFunction::ConstantText(Text *what)
// ----------------------------------------------------------------------------
//    Generate a Text tree
// ----------------------------------------------------------------------------
{
    JIT::Value_p result = code.PointerConstant(compiler.textTreePtrTy, what);
    return result;
}


JIT::Value_p CompilerFunction::ConstantTree(Tree *what)
// ----------------------------------------------------------------------------
//    Generate a constant tree
// ----------------------------------------------------------------------------
{
    JIT::Value_p result = code.PointerConstant(compiler.treePtrTy, what);
    return result;
}


JIT::Value_p CompilerFunction::CallFormError(Tree *what)
// ----------------------------------------------------------------------------
//   Report a type error trying to evaluate some argument
// ----------------------------------------------------------------------------
{
    JIT::Value_p ptr = ConstantTree(what);
    JIT::Value_p scope = ConstantTree(types->TypesScope());
    scope = code.BitCast(scope, compiler.scopePtrTy);
    JIT::Value_p callVal = code.Call(unit.xl_form_error, scope, ptr);
    return callVal;
}


JIT::Value_p CompilerFunction::CallTypeCheck(Tree *type, JIT::Value_p value)
// ----------------------------------------------------------------------------
//   Report a type error trying to evaluate some argument
// ----------------------------------------------------------------------------
{
    JIT::Value_p typePtr = ConstantTree(type);
    JIT::Value_p scope = ConstantTree(types->TypesScope());
    scope = code.BitCast(scope, compiler.scopePtrTy);
    JIT::Value_p callVal = code.Call(unit.xl_typecheck, scope, typePtr, value);
    return callVal;
}


JIT::Type_p CompilerFunction::ValueMachineType(Tree *tree, bool mayfail)
// ----------------------------------------------------------------------------
//    Return machine type associated to a type name or expression, if any
// ----------------------------------------------------------------------------
{
    // Find the base type for the expression
    Tree *base = types->CodeGenerationType(tree);
    if (!base)
    {
        if (mayfail)
            return nullptr;
        Ooops("Internal: No type deduced for $1, using natural", tree);
        return compiler.naturalTy;
    }

    // Find the corresponding machine type
    JIT::Type_p type = BoxedType(base);
    if (!type)
    {
        if (mayfail)
            return nullptr;
        Ooops("Internal: No type associated to $1", tree);
        return compiler.naturalTy;
    }

    return type;
}


void CompilerFunction::ValueMachineType(Tree *tree, JIT::Type_p type)
// ----------------------------------------------------------------------------
//    Record the global value associated to a type name or expression
// ----------------------------------------------------------------------------
{
    Tree *base = types->CodeGenerationType(tree);
    AddBoxedType(base, type);
}


void CompilerFunction::AddBoxedType(Tree *type, JIT::Type_p mtype)
// ----------------------------------------------------------------------------
//   Associate a tree type to a boxed machine type
// ----------------------------------------------------------------------------
///  The tree type could be a named type, e.g. [natural], or data, e.g. [X,Y]
//   The machine type could be naturalTy or StructType({naturalTy, realTy})
{
    types->AddBoxedType(type, mtype);
}


JIT::Type_p CompilerFunction::HasBoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the boxed type if there is one
// ----------------------------------------------------------------------------
{
    JIT::Type_p result = types->BoxedType(type);
    return result;
}


JIT::Type_p CompilerFunction::BoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the machine "boxed" type for a given tree type
// ----------------------------------------------------------------------------
{
    // Check if we already had it
    JIT::Type_p mtype = types->BoxedType(type);
    if (mtype)
        return mtype;
    Tree *base = types->BaseType(type);
    Context *context = types->TypesContext();
    bool isConstant = false;

    // Check if we have one of the basic types
#define CTYPE(name, cty)        if (base==name##_type) mtype = compiler.cty##Ty
#define STYPE(name)             CTYPE(name, name)
#define TTYPE(name)             CTYPE(name, name##TreePtr)

    // Check types for constants
    switch(type->Kind())
    {
    case NATURAL:
        isConstant = true;
        mtype = compiler.naturalTy;
        base = natural_type;
        break;
    case REAL:
        isConstant = true;
        mtype = compiler.realTy;
        base = real_type;
        break;
    case TEXT:
        isConstant = true;
        if (((Text *)type)->IsCharacter())
        {
            mtype = compiler.characterTy;
            base = character_type;
        }
        else
        {
            mtype = compiler.charPtrTy;
            base = text_type;
        }
        break;
    case NAME:
        if (Tree *declared = context->DeclaredPattern(type))
            if (declared != base)
                base = declared;

        if (base == xl_true || base == xl_false)
        {
            mtype = compiler.booleanTy;
            base = boolean_type;
        }
        if (base == nullptr)
            mtype = compiler.voidTy;
        if (base == error_type)
            mtype = compiler.treePtrTy;
        STYPE(boolean);
        STYPE(natural);
        STYPE(natural8);
        STYPE(natural16);
        STYPE(natural32);
        STYPE(natural64);
        CTYPE(natural,          natural64);
        CTYPE(natural8,         natural8);
        CTYPE(natural16,        natural16);
        CTYPE(natural32,        natural32);
        CTYPE(natural64,        natural64);
        STYPE(character);
        CTYPE(text,             charPtr);
        STYPE(real);
#if HAVE_FLOAT16
        STYPE(real16);
#endif // HAVE_FLOAT16
        STYPE(real32);
        STYPE(real64);
        CTYPE(tree,             treePtr);
        CTYPE(name,             nameTreePtr);
        CTYPE(symbol,           nameTreePtr);
        CTYPE(operator,         nameTreePtr);
        TTYPE(infix);
        CTYPE(definition,       infixTreePtr);
        TTYPE(prefix);
        TTYPE(postfix);
        TTYPE(block);
        break;

    case INFIX:
        if (Tree *pattern = types->IsPatternType(type))
            mtype = StructureType(pattern, type);
        break;

    case PREFIX:
        break;

    case POSTFIX:
        break;

    case BLOCK:
        if (Block *block = (Block *) type)
            mtype = BoxedType(block->child);
        break;
    }

    if (mtype)
        types->AddBoxedType(type, mtype);
    if (isConstant)
        types->AssignType(type, base);

    return mtype;
}


JIT::Type_p CompilerFunction::ReturnType(Tree *parmForm)
// ----------------------------------------------------------------------------
//   Compute the return type associated with the given form
// ----------------------------------------------------------------------------
{
    // Type inference gives us the return type for this form
    Tree *type = types->CodeGenerationType(parmForm);
    JIT::Type_p mtype = BoxedType(type);
    if (!mtype)
        mtype = jit.VoidType();
    return mtype;
}


JIT::Type_p CompilerFunction::StructureType(Tree *rwform,
                                            Tree *base)
// ----------------------------------------------------------------------------
//   Build a structure type when the signature is not known
// ----------------------------------------------------------------------------
{
    JIT::Signature signature;
    BoxedTreeType(signature, rwform);
    return StructureType(signature, rwform, base);
}


JIT::Type_p CompilerFunction::StructureType(const JIT::Signature &signature,
                                            Tree *rwform,
                                            Tree *base)
// ----------------------------------------------------------------------------
//   Compute the return type associated with a data form
// ----------------------------------------------------------------------------
{
    if (JIT::Type_p mtype = HasBoxedType(base))
        return mtype;

    // Build the corresponding structure type
    JIT::StructType_p stype = jit.StructType(signature, "boxed");

    // Record boxing and unboxing for that particular tree
    AddBoxedType(base, stype);
    UnboxFunction(stype, rwform);

    return stype;
}


JIT::Value_p CompilerFunction::BoxedTree(Tree *what)
// ----------------------------------------------------------------------------
//   Compute a boxed tree value
// ----------------------------------------------------------------------------
{
    if (Name *name = what->AsName())
    {
        Context *context = types->TypesContext();
        what = context->Bound(name);
    }

    // Compute the boxed type for the data
    JIT::Signature sig;
    BoxedTreeType(sig, what);
    Tree *base = types->BaseType(what);
    JIT::Type_p sty = StructureType(sig, what, base);
    record(compiler_function, "Boxed tree %t is type %v", what, sty);

    // Generate the data
    unsigned index = 0;
    JIT::Value_p box = NeedStorage(what, sty);
    JIT::Value_p result = Data(what, box, index);

    result = code.Load(box);
    return result;
}


void CompilerFunction::BoxedTreeType(JIT::Signature &sig, Tree *what)
// ----------------------------------------------------------------------------
//  Compute the signature for a boxed tree
// ----------------------------------------------------------------------------
{
    switch(what->Kind())
    {
    case NATURAL:
    case REAL:
    case TEXT:
        sig.push_back(BoxedType(what));
        break;

    case NAME:
        what = types->TypesContext()->DeclaredPattern(what);
        sig.push_back(ValueMachineType(what));
        break;

    case BLOCK:
        BoxedTreeType(sig, ((Block *) what)->child);
        break;
    case PREFIX:
        if (((Prefix *) what)->left->Kind() != NAME)
            BoxedTreeType(sig, ((Prefix *) what)->left);
        BoxedTreeType(sig, ((Prefix *) what)->right);
       break;
    case POSTFIX:
        if (((Postfix *) what)->right->Kind() != NAME)
            BoxedTreeType(sig, ((Postfix *) what)->right);
        BoxedTreeType(sig, ((Postfix *) what)->left);
        break;
    case INFIX:
        BoxedTreeType(sig, ((Infix *) what)->left);
        BoxedTreeType(sig, ((Infix *) what)->right);
        break;
    }
}


JIT::Value_p CompilerFunction::Primitive(Tree *what,
                                         text name,
                                         uint arity,
                                         JIT::Value_p *args)
// ----------------------------------------------------------------------------
//   Invoke an LLVM primitive, assuming it's found in the table
// ----------------------------------------------------------------------------
{
    // Find the entry in the primitives table
    auto found = primitives.find(name);
    if (found == primitives.end())
    {
        Ooops("Invalid primitive $1", what);
        return ConstantTree(what);
    }

    // If the entry doesn't have the expected arity, give up
    PrimitiveInfo &primitive = (*found).second;
    if (primitive.arity != arity)
    {
        Ooops("Primitive  arity for $1 is wrong, should be $2", what)
            .Arg(primitive.arity);
        return ConstantTree(what);
    }

    // Invoke the entry
    JIT::Value_p result = (this->*primitive.function)(what, args);
    return result;
}



// ============================================================================
//
//   Define all the LLVM wrappers
//
// ============================================================================

#define MTYPE(Name, Arity, Code)                                        \
    JIT::Type_p CompilerFunction::llvm_type_##Name(Tree *source)        \
    {                                                                   \
        Code;                                                           \
    }

#define UNARY(Name)                                                     \
    JIT::Value_p CompilerFunction::llvm_##Name(Tree *source,            \
                                               JIT::Value_p *args)      \
    {                                                                   \
        return code.Name(args[0]);                                      \
    }

#define BINARY(Name)                                                    \
    JIT::Value_p CompilerFunction::llvm_##Name(Tree *source,            \
                                               JIT::Value_p *args)      \
    {                                                                   \
        return code.Name(args[0], args[1]);                             \
    }

#define CAST(Name)                                                      \
    JIT::Value_p CompilerFunction::llvm_##Name(Tree *source,            \
                                               JIT::Value_p *args)      \
    {                                                                   \
        return code.Name(args[0], (JIT::Type_p) args[1]);               \
    }


#define SPECIAL(Name, Arity, Code)                                      \
    JIT::Value_p CompilerFunction::llvm_##Name(Tree *source,            \
                                               JIT::Value_p *args)      \
    {                                                                   \
        Code;                                                           \
    }

#define ALIAS(from, arity, to)
#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"



// ============================================================================
//
//    Compiler evaluation function
//
// ============================================================================

CompilerEval::CompilerEval(CompilerUnit &unit,
                           Tree *body,
                           CompilerTypes *types)
// ----------------------------------------------------------------------------
//   Build a compiler eval function
// ----------------------------------------------------------------------------
    : CompilerFunction(unit, body, body, types, unit.compiler.evalTy,
                       "xl.eval")
{
    InitializePrimitives();
    record(compiler_function, "Created evaluation %p for %t in %p as %v",
           this, body, types, function);
}

XL_END
